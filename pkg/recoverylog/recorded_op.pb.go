// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: recorded_op.proto

/*
	Package recoverylog is a generated protocol buffer package.

	It is generated from these files:
		recorded_op.proto

	It has these top-level messages:
		RecordedOp
		Property
		Segment
		FnodeSegments
		FSMHints
*/
package recoverylog

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import github_com_LiveRamp_gazette_pkg_journal "github.com/LiveRamp/gazette/pkg/journal"

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// RecordedOp records states changes occuring within a local file-system.
// Next tag: 9.
type RecordedOp struct {
	// Monotonically-increasing sequence number of this operation.
	SeqNo int64 `protobuf:"varint,1,opt,name=seq_no,json=seqNo,proto3" json:"seq_no,omitempty"`
	// Previous FSM checksum to which this operation should be applied (eg, the
	// expected checksum arrived at after applying the previous operation.
	Checksum uint32 `protobuf:"fixed32,2,opt,name=checksum,proto3" json:"checksum,omitempty"`
	// Author is the unique ID of the Recorder which write this RecordedOp.
	// Each Recorder randomly generates an Author ID at startup, and thereafter
	// applies it to all operations it records.
	Author Author             `protobuf:"fixed32,3,opt,name=author,proto3,casttype=Author" json:"author,omitempty"`
	Create *RecordedOp_Create `protobuf:"bytes,4,opt,name=create" json:"create,omitempty"`
	Link   *RecordedOp_Link   `protobuf:"bytes,5,opt,name=link" json:"link,omitempty"`
	Unlink *RecordedOp_Link   `protobuf:"bytes,6,opt,name=unlink" json:"unlink,omitempty"`
	Write  *RecordedOp_Write  `protobuf:"bytes,7,opt,name=write" json:"write,omitempty"`
	// Property indicates a property file has been created or updated.
	Property *Property `protobuf:"bytes,8,opt,name=property" json:"property,omitempty"`
}

func (m *RecordedOp) Reset()                    { *m = RecordedOp{} }
func (m *RecordedOp) String() string            { return proto.CompactTextString(m) }
func (*RecordedOp) ProtoMessage()               {}
func (*RecordedOp) Descriptor() ([]byte, []int) { return fileDescriptorRecordedOp, []int{0} }

func (m *RecordedOp) GetSeqNo() int64 {
	if m != nil {
		return m.SeqNo
	}
	return 0
}

func (m *RecordedOp) GetChecksum() uint32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

func (m *RecordedOp) GetAuthor() Author {
	if m != nil {
		return m.Author
	}
	return 0
}

func (m *RecordedOp) GetCreate() *RecordedOp_Create {
	if m != nil {
		return m.Create
	}
	return nil
}

func (m *RecordedOp) GetLink() *RecordedOp_Link {
	if m != nil {
		return m.Link
	}
	return nil
}

func (m *RecordedOp) GetUnlink() *RecordedOp_Link {
	if m != nil {
		return m.Unlink
	}
	return nil
}

func (m *RecordedOp) GetWrite() *RecordedOp_Write {
	if m != nil {
		return m.Write
	}
	return nil
}

func (m *RecordedOp) GetProperty() *Property {
	if m != nil {
		return m.Property
	}
	return nil
}

// Create a new "File Node" (Fnode), initially linked to |path|. Fnodes play
// a similar role to Posix inodes: they identify a specific file object while
// being invariant to (and spanning across) its current or future path links.
// The assigned Fnode ID is the |seq_no| of this RecordedOp.
type RecordedOp_Create struct {
	// Filesystem path of this file, relative to the common base directory.
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
}

func (m *RecordedOp_Create) Reset()                    { *m = RecordedOp_Create{} }
func (m *RecordedOp_Create) String() string            { return proto.CompactTextString(m) }
func (*RecordedOp_Create) ProtoMessage()               {}
func (*RecordedOp_Create) Descriptor() ([]byte, []int) { return fileDescriptorRecordedOp, []int{0, 0} }

func (m *RecordedOp_Create) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

// Link or unlink an Fnode to a filesystem path.
type RecordedOp_Link struct {
	// Fnode being linked or unlinked.
	Fnode Fnode `protobuf:"varint,1,opt,name=fnode,proto3,casttype=Fnode" json:"fnode,omitempty"`
	// Filesystem path being un/linked, relative to the common base directory.
	Path string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
}

func (m *RecordedOp_Link) Reset()                    { *m = RecordedOp_Link{} }
func (m *RecordedOp_Link) String() string            { return proto.CompactTextString(m) }
func (*RecordedOp_Link) ProtoMessage()               {}
func (*RecordedOp_Link) Descriptor() ([]byte, []int) { return fileDescriptorRecordedOp, []int{0, 1} }

func (m *RecordedOp_Link) GetFnode() Fnode {
	if m != nil {
		return m.Fnode
	}
	return 0
}

func (m *RecordedOp_Link) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

// Write indicates |length| bytes should be written at |offset| to |fnode|.
// In a serialization stream, we expect |length| raw bytes of content to
// immediately follow this operation.
type RecordedOp_Write struct {
	// Fnode being written to.
	Fnode Fnode `protobuf:"varint,1,opt,name=fnode,proto3,casttype=Fnode" json:"fnode,omitempty"`
	// Byte-offset within the file to which this write is applied.
	Offset int64 `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	// Length of the write.
	Length int64 `protobuf:"varint,3,opt,name=length,proto3" json:"length,omitempty"`
}

func (m *RecordedOp_Write) Reset()                    { *m = RecordedOp_Write{} }
func (m *RecordedOp_Write) String() string            { return proto.CompactTextString(m) }
func (*RecordedOp_Write) ProtoMessage()               {}
func (*RecordedOp_Write) Descriptor() ([]byte, []int) { return fileDescriptorRecordedOp, []int{0, 2} }

func (m *RecordedOp_Write) GetFnode() Fnode {
	if m != nil {
		return m.Fnode
	}
	return 0
}

func (m *RecordedOp_Write) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *RecordedOp_Write) GetLength() int64 {
	if m != nil {
		return m.Length
	}
	return 0
}

// Property is a small file which rarely changes, and is thus managed
// outside of regular Fnode tracking. See FSM.Properties.
type Property struct {
	// Filesystem path of this property, relative to the common base directory.
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// Complete file content of this property.
	Content string `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *Property) Reset()                    { *m = Property{} }
func (m *Property) String() string            { return proto.CompactTextString(m) }
func (*Property) ProtoMessage()               {}
func (*Property) Descriptor() ([]byte, []int) { return fileDescriptorRecordedOp, []int{1} }

func (m *Property) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Property) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

// Segment is a contiguous chunk of recovery log written by a single Author.
// Recorders track Segments they have written, for use in providing hints to
// future readers of the log. A key point to understand is that Gazette append
// semantics mean that Recorders *cannot know* exactly what offsets their writes
// are applied to in the log, nor guarantee that their operations are not being
// interleaved with those of other writers. Log Players are aware of these
// limitations, and use Segments to resolve conflicts of possible interpretation
// of the log. Segments produced by a Player are exact, since Players observe all
// recorded operations at their exact offsets.
// Next tag: 6.
type Segment struct {
	// Author which wrote RecordedOps of this Segment.
	Author Author `protobuf:"fixed32,1,opt,name=author,proto3,casttype=Author" json:"author,omitempty"`
	// First (lowest) sequence number of RecordedOps within this Segment.
	FirstSeqNo int64 `protobuf:"varint,2,opt,name=first_seq_no,json=firstSeqNo,proto3" json:"first_seq_no,omitempty"`
	// First byte offset of the Segment, where |first_seq_no| is recorded.
	// If this Segment was produced by a Recorder, this is guaranteed only to be a
	// lower-bound (eg, a Player reading at this offset may encounter irrelevant
	// operations prior to the RecordedOp indicated by the tuple
	// (|author|, |first_seq_no|, |first_checksum|). If a Player produced the Segment,
	// first_offset is exact.
	FirstOffset int64 `protobuf:"varint,3,opt,name=first_offset,json=firstOffset,proto3" json:"first_offset,omitempty"`
	// Checksum of the RecordedOp having |first_seq_no|.
	FirstChecksum uint32 `protobuf:"fixed32,4,opt,name=first_checksum,json=firstChecksum,proto3" json:"first_checksum,omitempty"`
	// Last (highest) sequence number of RecordedOps within this Segment.
	LastSeqNo int64 `protobuf:"varint,5,opt,name=last_seq_no,json=lastSeqNo,proto3" json:"last_seq_no,omitempty"`
}

func (m *Segment) Reset()                    { *m = Segment{} }
func (m *Segment) String() string            { return proto.CompactTextString(m) }
func (*Segment) ProtoMessage()               {}
func (*Segment) Descriptor() ([]byte, []int) { return fileDescriptorRecordedOp, []int{2} }

func (m *Segment) GetAuthor() Author {
	if m != nil {
		return m.Author
	}
	return 0
}

func (m *Segment) GetFirstSeqNo() int64 {
	if m != nil {
		return m.FirstSeqNo
	}
	return 0
}

func (m *Segment) GetFirstOffset() int64 {
	if m != nil {
		return m.FirstOffset
	}
	return 0
}

func (m *Segment) GetFirstChecksum() uint32 {
	if m != nil {
		return m.FirstChecksum
	}
	return 0
}

func (m *Segment) GetLastSeqNo() int64 {
	if m != nil {
		return m.LastSeqNo
	}
	return 0
}

// FnodeSegments captures log Segments containing all RecordedOps of the Fnode.
type FnodeSegments struct {
	// Fnode being hinted.
	Fnode Fnode `protobuf:"varint,1,opt,name=fnode,proto3,casttype=Fnode" json:"fnode,omitempty"`
	// Segments of the Fnode in the log. Currently, FSM tracks only a single
	// Segment per Fnode per Author. A specific implication of this is that Fnodes
	// modified over long periods of time will result in Segments spanning large
	// chunks of the log. For best performance, Fnodes should be opened & written
	// once, and then never be modified again (this is RocksDB's behavior).
	// If supporting this case is desired, FSM will have to be a bit smarter about
	// not extending Segments which gap over significant portions of the log
	// (eg, there's a trade-off to make over size of the hinted manifest, vs
	// savings incurred on playback by being able to skip portions of the log).
	Segments []Segment `protobuf:"bytes,2,rep,name=segments" json:"segments"`
}

func (m *FnodeSegments) Reset()                    { *m = FnodeSegments{} }
func (m *FnodeSegments) String() string            { return proto.CompactTextString(m) }
func (*FnodeSegments) ProtoMessage()               {}
func (*FnodeSegments) Descriptor() ([]byte, []int) { return fileDescriptorRecordedOp, []int{3} }

func (m *FnodeSegments) GetFnode() Fnode {
	if m != nil {
		return m.Fnode
	}
	return 0
}

func (m *FnodeSegments) GetSegments() []Segment {
	if m != nil {
		return m.Segments
	}
	return nil
}

// FSMHints represents a manifest of Fnodes which were still live (eg, having
// remaining links) at the time the FSMHints were produced, as well as any
// Properties. It allows a Player of the log to identify minimal Segments which
// must be read to recover all Fnodes, and also contains sufficient metadata for
// a Player to resolve all possible conflicts it could encounter while reading
// the log, to arrive at a consistent view of file state which exactly matches
// that of the Recorder producing the FSMHints.
// Next tag: 4.
type FSMHints struct {
	// Log is the Journal name holding recorded log content.
	Log github_com_LiveRamp_gazette_pkg_journal.Name `protobuf:"bytes,1,opt,name=log,proto3,casttype=github.com/LiveRamp/gazette/pkg/journal.Name" json:"log,omitempty"`
	// Live Fnodes and their Segments as-of the generation of these FSMHints.
	LiveNodes []FnodeSegments `protobuf:"bytes,2,rep,name=live_nodes,json=liveNodes" json:"live_nodes"`
	// Property files and contents as-of the generation of these FSMHints.
	Properties []Property `protobuf:"bytes,3,rep,name=properties" json:"properties"`
}

func (m *FSMHints) Reset()                    { *m = FSMHints{} }
func (m *FSMHints) String() string            { return proto.CompactTextString(m) }
func (*FSMHints) ProtoMessage()               {}
func (*FSMHints) Descriptor() ([]byte, []int) { return fileDescriptorRecordedOp, []int{4} }

func (m *FSMHints) GetLog() github_com_LiveRamp_gazette_pkg_journal.Name {
	if m != nil {
		return m.Log
	}
	return ""
}

func (m *FSMHints) GetLiveNodes() []FnodeSegments {
	if m != nil {
		return m.LiveNodes
	}
	return nil
}

func (m *FSMHints) GetProperties() []Property {
	if m != nil {
		return m.Properties
	}
	return nil
}

func init() {
	proto.RegisterType((*RecordedOp)(nil), "recoverylog.RecordedOp")
	proto.RegisterType((*RecordedOp_Create)(nil), "recoverylog.RecordedOp.Create")
	proto.RegisterType((*RecordedOp_Link)(nil), "recoverylog.RecordedOp.Link")
	proto.RegisterType((*RecordedOp_Write)(nil), "recoverylog.RecordedOp.Write")
	proto.RegisterType((*Property)(nil), "recoverylog.Property")
	proto.RegisterType((*Segment)(nil), "recoverylog.Segment")
	proto.RegisterType((*FnodeSegments)(nil), "recoverylog.FnodeSegments")
	proto.RegisterType((*FSMHints)(nil), "recoverylog.FSMHints")
}
func (m *RecordedOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordedOp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SeqNo != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRecordedOp(dAtA, i, uint64(m.SeqNo))
	}
	if m.Checksum != 0 {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.Checksum))
		i += 4
	}
	if m.Author != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.Author))
		i += 4
	}
	if m.Create != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRecordedOp(dAtA, i, uint64(m.Create.Size()))
		n1, err := m.Create.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Link != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRecordedOp(dAtA, i, uint64(m.Link.Size()))
		n2, err := m.Link.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Unlink != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRecordedOp(dAtA, i, uint64(m.Unlink.Size()))
		n3, err := m.Unlink.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Write != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintRecordedOp(dAtA, i, uint64(m.Write.Size()))
		n4, err := m.Write.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Property != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintRecordedOp(dAtA, i, uint64(m.Property.Size()))
		n5, err := m.Property.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *RecordedOp_Create) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordedOp_Create) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRecordedOp(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	return i, nil
}

func (m *RecordedOp_Link) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordedOp_Link) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fnode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRecordedOp(dAtA, i, uint64(m.Fnode))
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRecordedOp(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	return i, nil
}

func (m *RecordedOp_Write) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordedOp_Write) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fnode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRecordedOp(dAtA, i, uint64(m.Fnode))
	}
	if m.Offset != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRecordedOp(dAtA, i, uint64(m.Offset))
	}
	if m.Length != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRecordedOp(dAtA, i, uint64(m.Length))
	}
	return i, nil
}

func (m *Property) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Property) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRecordedOp(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRecordedOp(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	return i, nil
}

func (m *Segment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Segment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Author != 0 {
		dAtA[i] = 0xd
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.Author))
		i += 4
	}
	if m.FirstSeqNo != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRecordedOp(dAtA, i, uint64(m.FirstSeqNo))
	}
	if m.FirstOffset != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRecordedOp(dAtA, i, uint64(m.FirstOffset))
	}
	if m.FirstChecksum != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.FirstChecksum))
		i += 4
	}
	if m.LastSeqNo != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRecordedOp(dAtA, i, uint64(m.LastSeqNo))
	}
	return i, nil
}

func (m *FnodeSegments) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FnodeSegments) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fnode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRecordedOp(dAtA, i, uint64(m.Fnode))
	}
	if len(m.Segments) > 0 {
		for _, msg := range m.Segments {
			dAtA[i] = 0x12
			i++
			i = encodeVarintRecordedOp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FSMHints) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FSMHints) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Log) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRecordedOp(dAtA, i, uint64(len(m.Log)))
		i += copy(dAtA[i:], m.Log)
	}
	if len(m.LiveNodes) > 0 {
		for _, msg := range m.LiveNodes {
			dAtA[i] = 0x12
			i++
			i = encodeVarintRecordedOp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Properties) > 0 {
		for _, msg := range m.Properties {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintRecordedOp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintRecordedOp(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *RecordedOp) Size() (n int) {
	var l int
	_ = l
	if m.SeqNo != 0 {
		n += 1 + sovRecordedOp(uint64(m.SeqNo))
	}
	if m.Checksum != 0 {
		n += 5
	}
	if m.Author != 0 {
		n += 5
	}
	if m.Create != nil {
		l = m.Create.Size()
		n += 1 + l + sovRecordedOp(uint64(l))
	}
	if m.Link != nil {
		l = m.Link.Size()
		n += 1 + l + sovRecordedOp(uint64(l))
	}
	if m.Unlink != nil {
		l = m.Unlink.Size()
		n += 1 + l + sovRecordedOp(uint64(l))
	}
	if m.Write != nil {
		l = m.Write.Size()
		n += 1 + l + sovRecordedOp(uint64(l))
	}
	if m.Property != nil {
		l = m.Property.Size()
		n += 1 + l + sovRecordedOp(uint64(l))
	}
	return n
}

func (m *RecordedOp_Create) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovRecordedOp(uint64(l))
	}
	return n
}

func (m *RecordedOp_Link) Size() (n int) {
	var l int
	_ = l
	if m.Fnode != 0 {
		n += 1 + sovRecordedOp(uint64(m.Fnode))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovRecordedOp(uint64(l))
	}
	return n
}

func (m *RecordedOp_Write) Size() (n int) {
	var l int
	_ = l
	if m.Fnode != 0 {
		n += 1 + sovRecordedOp(uint64(m.Fnode))
	}
	if m.Offset != 0 {
		n += 1 + sovRecordedOp(uint64(m.Offset))
	}
	if m.Length != 0 {
		n += 1 + sovRecordedOp(uint64(m.Length))
	}
	return n
}

func (m *Property) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovRecordedOp(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovRecordedOp(uint64(l))
	}
	return n
}

func (m *Segment) Size() (n int) {
	var l int
	_ = l
	if m.Author != 0 {
		n += 5
	}
	if m.FirstSeqNo != 0 {
		n += 1 + sovRecordedOp(uint64(m.FirstSeqNo))
	}
	if m.FirstOffset != 0 {
		n += 1 + sovRecordedOp(uint64(m.FirstOffset))
	}
	if m.FirstChecksum != 0 {
		n += 5
	}
	if m.LastSeqNo != 0 {
		n += 1 + sovRecordedOp(uint64(m.LastSeqNo))
	}
	return n
}

func (m *FnodeSegments) Size() (n int) {
	var l int
	_ = l
	if m.Fnode != 0 {
		n += 1 + sovRecordedOp(uint64(m.Fnode))
	}
	if len(m.Segments) > 0 {
		for _, e := range m.Segments {
			l = e.Size()
			n += 1 + l + sovRecordedOp(uint64(l))
		}
	}
	return n
}

func (m *FSMHints) Size() (n int) {
	var l int
	_ = l
	l = len(m.Log)
	if l > 0 {
		n += 1 + l + sovRecordedOp(uint64(l))
	}
	if len(m.LiveNodes) > 0 {
		for _, e := range m.LiveNodes {
			l = e.Size()
			n += 1 + l + sovRecordedOp(uint64(l))
		}
	}
	if len(m.Properties) > 0 {
		for _, e := range m.Properties {
			l = e.Size()
			n += 1 + l + sovRecordedOp(uint64(l))
		}
	}
	return n
}

func sovRecordedOp(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRecordedOp(x uint64) (n int) {
	return sovRecordedOp(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RecordedOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecordedOp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordedOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordedOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNo", wireType)
			}
			m.SeqNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecordedOp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNo |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			m.Checksum = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.Checksum = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			m.Author = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = Author(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Create", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecordedOp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecordedOp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Create == nil {
				m.Create = &RecordedOp_Create{}
			}
			if err := m.Create.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecordedOp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecordedOp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Link == nil {
				m.Link = &RecordedOp_Link{}
			}
			if err := m.Link.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unlink", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecordedOp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecordedOp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Unlink == nil {
				m.Unlink = &RecordedOp_Link{}
			}
			if err := m.Unlink.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Write", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecordedOp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecordedOp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Write == nil {
				m.Write = &RecordedOp_Write{}
			}
			if err := m.Write.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Property", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecordedOp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecordedOp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Property == nil {
				m.Property = &Property{}
			}
			if err := m.Property.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecordedOp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecordedOp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordedOp_Create) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecordedOp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Create: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Create: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecordedOp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecordedOp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecordedOp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecordedOp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordedOp_Link) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecordedOp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Link: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Link: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fnode", wireType)
			}
			m.Fnode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecordedOp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fnode |= (Fnode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecordedOp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecordedOp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecordedOp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecordedOp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordedOp_Write) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecordedOp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Write: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Write: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fnode", wireType)
			}
			m.Fnode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecordedOp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fnode |= (Fnode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecordedOp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecordedOp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRecordedOp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecordedOp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Property) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecordedOp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Property: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Property: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecordedOp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecordedOp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecordedOp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecordedOp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecordedOp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecordedOp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Segment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecordedOp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Segment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Segment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			m.Author = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = Author(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstSeqNo", wireType)
			}
			m.FirstSeqNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecordedOp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FirstSeqNo |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstOffset", wireType)
			}
			m.FirstOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecordedOp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FirstOffset |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstChecksum", wireType)
			}
			m.FirstChecksum = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstChecksum = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSeqNo", wireType)
			}
			m.LastSeqNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecordedOp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastSeqNo |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRecordedOp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecordedOp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FnodeSegments) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecordedOp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FnodeSegments: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FnodeSegments: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fnode", wireType)
			}
			m.Fnode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecordedOp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fnode |= (Fnode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Segments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecordedOp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecordedOp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Segments = append(m.Segments, Segment{})
			if err := m.Segments[len(m.Segments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecordedOp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecordedOp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FSMHints) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecordedOp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FSMHints: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FSMHints: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Log", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecordedOp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecordedOp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Log = github_com_LiveRamp_gazette_pkg_journal.Name(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecordedOp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecordedOp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LiveNodes = append(m.LiveNodes, FnodeSegments{})
			if err := m.LiveNodes[len(m.LiveNodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecordedOp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecordedOp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Properties = append(m.Properties, Property{})
			if err := m.Properties[len(m.Properties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecordedOp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecordedOp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRecordedOp(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRecordedOp
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRecordedOp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRecordedOp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRecordedOp
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRecordedOp
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRecordedOp(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRecordedOp = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRecordedOp   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("recorded_op.proto", fileDescriptorRecordedOp) }

var fileDescriptorRecordedOp = []byte{
	// 619 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x54, 0x4d, 0x6f, 0xd3, 0x40,
	0x10, 0xad, 0xeb, 0x8f, 0x24, 0x93, 0x16, 0x89, 0x15, 0x45, 0x56, 0x04, 0x49, 0x88, 0x84, 0x94,
	0x03, 0x38, 0xa5, 0x45, 0x3d, 0x80, 0x04, 0xaa, 0x2b, 0x55, 0x1c, 0x4a, 0x8b, 0xb6, 0x07, 0x6e,
	0x44, 0xae, 0xbb, 0x71, 0x4c, 0x1c, 0xaf, 0x6b, 0xaf, 0x8b, 0xca, 0xbf, 0xe1, 0x5f, 0x70, 0xe3,
	0xda, 0x63, 0xc5, 0x0f, 0x88, 0x50, 0x7f, 0x46, 0x4f, 0x68, 0x67, 0x37, 0x69, 0x22, 0x1a, 0x95,
	0x4b, 0xe4, 0x99, 0x7d, 0x6f, 0xe6, 0xbd, 0xf5, 0x73, 0xe0, 0x61, 0xce, 0x42, 0x9e, 0x9f, 0xb2,
	0xd3, 0x3e, 0xcf, 0xbc, 0x2c, 0xe7, 0x82, 0x93, 0xba, 0x6c, 0x9d, 0xb3, 0xfc, 0x22, 0xe1, 0x51,
	0xe3, 0x65, 0x14, 0x8b, 0x61, 0x79, 0xe2, 0x85, 0x7c, 0xdc, 0x8b, 0x78, 0xc4, 0x7b, 0x88, 0x39,
	0x29, 0x07, 0x58, 0x61, 0x81, 0x4f, 0x8a, 0xdb, 0xf9, 0x69, 0x01, 0x50, 0x3d, 0xf1, 0x28, 0x23,
	0x1b, 0xe0, 0x14, 0xec, 0xac, 0x9f, 0x72, 0xd7, 0x68, 0x1b, 0x5d, 0x93, 0xda, 0x05, 0x3b, 0x3b,
	0xe4, 0xa4, 0x01, 0xd5, 0x70, 0xc8, 0xc2, 0x51, 0x51, 0x8e, 0xdd, 0xd5, 0xb6, 0xd1, 0xad, 0xd0,
	0x59, 0x4d, 0x3a, 0xe0, 0x04, 0xa5, 0x18, 0xf2, 0xdc, 0x35, 0xe5, 0x89, 0x0f, 0x37, 0x93, 0x96,
	0xb3, 0x8b, 0x1d, 0xaa, 0x4f, 0xc8, 0x0e, 0x38, 0x61, 0xce, 0x02, 0xc1, 0x5c, 0xab, 0x6d, 0x74,
	0xeb, 0x5b, 0x4d, 0x6f, 0x4e, 0xb2, 0x77, 0xbb, 0xdf, 0xdb, 0x43, 0x14, 0xd5, 0x68, 0xb2, 0x09,
	0x56, 0x12, 0xa7, 0x23, 0xd7, 0x46, 0xd6, 0x93, 0x65, 0xac, 0x83, 0x38, 0x1d, 0x51, 0x44, 0x92,
	0xd7, 0xe0, 0x94, 0x29, 0x72, 0x9c, 0xff, 0xe0, 0x68, 0x2c, 0xd9, 0x06, 0xfb, 0x5b, 0x1e, 0x0b,
	0xe6, 0x56, 0x90, 0xf4, 0x74, 0x19, 0xe9, 0xb3, 0x04, 0x51, 0x85, 0x25, 0xaf, 0xa0, 0x9a, 0xe5,
	0x3c, 0x63, 0xb9, 0xb8, 0x70, 0xab, 0xc8, 0xdb, 0x58, 0xe0, 0x7d, 0xd2, 0x87, 0x74, 0x06, 0x6b,
	0x74, 0xc0, 0x51, 0x0e, 0x09, 0x01, 0x2b, 0x0b, 0xc4, 0x10, 0xaf, 0xb9, 0x46, 0xf1, 0xf9, 0x8d,
	0x75, 0xf5, 0xa3, 0xb5, 0xd2, 0xd8, 0x05, 0x4b, 0x6a, 0x23, 0x2d, 0xb0, 0x07, 0x29, 0x3f, 0x65,
	0xea, 0x4d, 0xf8, 0xb5, 0x9b, 0x49, 0xcb, 0xde, 0x97, 0x0d, 0xaa, 0xfa, 0xb3, 0x11, 0xab, 0xff,
	0x8c, 0xf8, 0x02, 0x36, 0x2a, 0xbd, 0x7f, 0xc6, 0x63, 0x70, 0xf8, 0x60, 0x50, 0x30, 0x81, 0x53,
	0x4c, 0xaa, 0x2b, 0xd9, 0x4f, 0x58, 0x1a, 0x89, 0x21, 0xbe, 0x54, 0x93, 0xea, 0x4a, 0xcd, 0x57,
	0xbf, 0x9d, 0x77, 0x50, 0x9d, 0x5a, 0xbc, 0xcb, 0x0e, 0x71, 0xa1, 0x12, 0xf2, 0x54, 0xb0, 0x54,
	0x68, 0x89, 0xd3, 0x52, 0xf3, 0x7f, 0x19, 0x50, 0x39, 0x66, 0xd1, 0x98, 0xa5, 0x62, 0x2e, 0x44,
	0xc6, 0xd2, 0x10, 0xb5, 0x61, 0x6d, 0x10, 0xe7, 0x85, 0xe8, 0xeb, 0x84, 0x2a, 0xc5, 0x80, 0xbd,
	0x63, 0x8c, 0xe9, 0xb3, 0x29, 0x42, 0x7b, 0x52, 0xda, 0xeb, 0xd8, 0x3b, 0x52, 0xc6, 0x9e, 0xc3,
	0x03, 0x05, 0x99, 0xe5, 0xd9, 0xc2, 0x3c, 0xaf, 0x63, 0x77, 0x6f, 0x1a, 0xea, 0x26, 0xd4, 0x93,
	0xe0, 0x76, 0x95, 0x8d, 0x83, 0x6a, 0xb2, 0x85, 0x9b, 0xb4, 0x83, 0x14, 0xd6, 0xf1, 0x36, 0xb5,
	0x8b, 0xe2, 0xfe, 0xfb, 0xde, 0x81, 0x6a, 0xa1, 0xc1, 0xee, 0x6a, 0xdb, 0xec, 0xd6, 0xb7, 0x1e,
	0x2d, 0x64, 0x46, 0x4f, 0xf2, 0xad, 0xcb, 0x49, 0x6b, 0x85, 0xce, 0xb0, 0x7a, 0xdf, 0x6f, 0x03,
	0xaa, 0xfb, 0xc7, 0x1f, 0x3f, 0xc4, 0x72, 0x97, 0x0f, 0x66, 0xc2, 0x23, 0x75, 0xe3, 0xfe, 0xe6,
	0xcd, 0xa4, 0xf5, 0x62, 0xee, 0xcb, 0x3f, 0x88, 0xcf, 0x19, 0x0d, 0xc6, 0x59, 0x2f, 0x0a, 0xbe,
	0x33, 0x21, 0x58, 0x2f, 0x1b, 0x45, 0xbd, 0xaf, 0xbc, 0xcc, 0xd3, 0x20, 0xf1, 0x0e, 0x83, 0x31,
	0xa3, 0x92, 0x4c, 0xde, 0x03, 0x24, 0xf1, 0x39, 0xeb, 0x4b, 0x6d, 0x53, 0x41, 0x8d, 0x05, 0x41,
	0x0b, 0xfe, 0xb4, 0xac, 0x9a, 0xe4, 0x1c, 0x4a, 0x0a, 0x79, 0x0b, 0xa0, 0xc3, 0x1d, 0xb3, 0xc2,
	0x35, 0x71, 0xc0, 0xdd, 0x5f, 0x81, 0xe6, 0xce, 0xc1, 0x95, 0x29, 0x7f, 0xed, 0xf2, 0xba, 0x69,
	0x5c, 0x5d, 0x37, 0x8d, 0x3f, 0xd7, 0x4d, 0xe3, 0xc4, 0xc1, 0xbf, 0xa5, 0xed, 0xbf, 0x01, 0x00,
	0x00, 0xff, 0xff, 0x0b, 0xc8, 0x06, 0x04, 0xe7, 0x04, 0x00, 0x00,
}
