// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: broker/protocol/protocol.proto

package protocol

import (
	bytes "bytes"
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "github.com/golang/protobuf/ptypes/duration"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Status is a response status code, used universally across Gazette RPC APIs.
type Status int32

const (
	Status_OK Status = 0
	// The named journal does not exist.
	Status_JOURNAL_NOT_FOUND Status = 1
	// There is no current primary broker for the journal. This is a temporary
	// condition which should quickly resolve, assuming sufficient broker
	// capacity.
	Status_NO_JOURNAL_PRIMARY_BROKER Status = 2
	// The present broker is not the assigned primary broker for the journal.
	Status_NOT_JOURNAL_PRIMARY_BROKER Status = 3
	// The present broker is not an assigned broker for the journal.
	Status_NOT_JOURNAL_BROKER Status = 5
	// There are an insufficient number of assigned brokers for the journal
	// to meet its required replication.
	Status_INSUFFICIENT_JOURNAL_BROKERS Status = 4
	// The requested offset is not yet available. This indicates either that the
	// offset has not yet been written, or that the broker is not yet aware of a
	// written fragment covering the offset. Returned only by non-blocking reads.
	Status_OFFSET_NOT_YET_AVAILABLE Status = 6
	// The peer disagrees with the Route accompanying a ReplicateRequest.
	Status_WRONG_ROUTE Status = 7
	// The peer disagrees with the proposal accompanying a ReplicateRequest.
	Status_PROPOSAL_MISMATCH Status = 8
	// The Etcd transaction failed. Returned by Update RPC when an
	// expect_mod_revision of the UpdateRequest differs from the current
	// ModRevision of the JournalSpec within the store.
	Status_ETCD_TRANSACTION_FAILED Status = 9
	// A disallowed journal access was attempted (eg, a write where the
	// journal disables writes, or read where journals disable reads).
	Status_NOT_ALLOWED Status = 10
	// The Append is refused because its requested offset is not equal
	// to the furthest written offset of the journal.
	Status_WRONG_APPEND_OFFSET Status = 11
	// The Append is refused because the replication pipeline tracks a smaller
	// journal offset than that of the remote fragment index. This indicates
	// that journal replication consistency has been lost in the past, due to
	// too many broker or Etcd failures.
	Status_INDEX_HAS_GREATER_OFFSET Status = 12
	// The Append is refused because a registers selector was provided with the
	// request, but it was not matched by current register values of the journal.
	Status_REGISTER_MISMATCH Status = 13
)

var Status_name = map[int32]string{
	0:  "OK",
	1:  "JOURNAL_NOT_FOUND",
	2:  "NO_JOURNAL_PRIMARY_BROKER",
	3:  "NOT_JOURNAL_PRIMARY_BROKER",
	5:  "NOT_JOURNAL_BROKER",
	4:  "INSUFFICIENT_JOURNAL_BROKERS",
	6:  "OFFSET_NOT_YET_AVAILABLE",
	7:  "WRONG_ROUTE",
	8:  "PROPOSAL_MISMATCH",
	9:  "ETCD_TRANSACTION_FAILED",
	10: "NOT_ALLOWED",
	11: "WRONG_APPEND_OFFSET",
	12: "INDEX_HAS_GREATER_OFFSET",
	13: "REGISTER_MISMATCH",
}

var Status_value = map[string]int32{
	"OK":                           0,
	"JOURNAL_NOT_FOUND":            1,
	"NO_JOURNAL_PRIMARY_BROKER":    2,
	"NOT_JOURNAL_PRIMARY_BROKER":   3,
	"NOT_JOURNAL_BROKER":           5,
	"INSUFFICIENT_JOURNAL_BROKERS": 4,
	"OFFSET_NOT_YET_AVAILABLE":     6,
	"WRONG_ROUTE":                  7,
	"PROPOSAL_MISMATCH":            8,
	"ETCD_TRANSACTION_FAILED":      9,
	"NOT_ALLOWED":                  10,
	"WRONG_APPEND_OFFSET":          11,
	"INDEX_HAS_GREATER_OFFSET":     12,
	"REGISTER_MISMATCH":            13,
}

func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}

func (Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0c0999e5af553218, []int{0}
}

// CompressionCode defines codecs known to Gazette.
type CompressionCodec int32

const (
	// INVALID is the zero-valued CompressionCodec, and is not a valid codec.
	CompressionCodec_INVALID CompressionCodec = 0
	// NONE encodes Fragments without any applied compression, with default suffix
	// ".raw".
	CompressionCodec_NONE CompressionCodec = 1
	// GZIP encodes Fragments using the Gzip library, with default suffix ".gz".
	CompressionCodec_GZIP CompressionCodec = 2
	// ZSTANDARD encodes Fragments using the ZStandard library, with default
	// suffix ".zst".
	CompressionCodec_ZSTANDARD CompressionCodec = 3
	// SNAPPY encodes Fragments using the Snappy library, with default suffix
	// ".sz".
	CompressionCodec_SNAPPY CompressionCodec = 4
	// GZIP_OFFLOAD_DECOMPRESSION is the GZIP codec with additional behavior
	// around reads and writes to remote Fragment stores, designed to offload
	// the work of decompression onto compatible stores. Specifically:
	//  * Fragments are written with a "Content-Encoding: gzip" header.
	//  * Client read requests are made with "Accept-Encoding: identity".
	// This can be helpful in contexts where reader IO bandwidth to the storage
	// API is unconstrained, as the cost of decompression is offloaded to the
	// store and CPU-intensive batch readers may receive a parallelism benefit.
	// While this codec may provide substantial read-time performance
	// improvements, it is an advanced configuration and the "Content-Encoding"
	// header handling can be subtle and sometimes confusing. It uses the default
	// suffix ".gzod".
	CompressionCodec_GZIP_OFFLOAD_DECOMPRESSION CompressionCodec = 5
)

var CompressionCodec_name = map[int32]string{
	0: "INVALID",
	1: "NONE",
	2: "GZIP",
	3: "ZSTANDARD",
	4: "SNAPPY",
	5: "GZIP_OFFLOAD_DECOMPRESSION",
}

var CompressionCodec_value = map[string]int32{
	"INVALID":                    0,
	"NONE":                       1,
	"GZIP":                       2,
	"ZSTANDARD":                  3,
	"SNAPPY":                     4,
	"GZIP_OFFLOAD_DECOMPRESSION": 5,
}

func (x CompressionCodec) String() string {
	return proto.EnumName(CompressionCodec_name, int32(x))
}

func (CompressionCodec) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0c0999e5af553218, []int{1}
}

// Flags define Journal IO control behaviors. Where possible, flags are named
// after an equivalent POSIX flag.
type JournalSpec_Flag int32

const (
	// NOT_SPECIFIED is considered as equivalent to O_RDWR by the broker. When
	// JournalSpecs are union'ed (eg, by the `journalspace` pkg), NOT_SPECIFIED
	// is considered as unset relative to any other non-zero Flag value.
	JournalSpec_NOT_SPECIFIED JournalSpec_Flag = 0
	// The Journal is available for reads (only).
	JournalSpec_O_RDONLY JournalSpec_Flag = 1
	// The Journal is available for writes (only).
	JournalSpec_O_WRONLY JournalSpec_Flag = 2
	// The Journal may be used for reads or writes.
	JournalSpec_O_RDWR JournalSpec_Flag = 4
)

var JournalSpec_Flag_name = map[int32]string{
	0: "NOT_SPECIFIED",
	1: "O_RDONLY",
	2: "O_WRONLY",
	4: "O_RDWR",
}

var JournalSpec_Flag_value = map[string]int32{
	"NOT_SPECIFIED": 0,
	"O_RDONLY":      1,
	"O_WRONLY":      2,
	"O_RDWR":        4,
}

func (x JournalSpec_Flag) String() string {
	return proto.EnumName(JournalSpec_Flag_name, int32(x))
}

func (JournalSpec_Flag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0c0999e5af553218, []int{3, 0}
}

// Label defines a key & value pair which can be attached to entities like
// JournalSpecs and BrokerSpecs. Labels may be used to provide identifying
// attributes which do not directly imply semantics to the core system, but
// are meaningful to users or for higher-level Gazette tools.
type Label struct {
	Name  string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Label) Reset()         { *m = Label{} }
func (m *Label) String() string { return proto.CompactTextString(m) }
func (*Label) ProtoMessage()    {}
func (*Label) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c0999e5af553218, []int{0}
}
func (m *Label) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Label) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Label.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Label) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Label.Merge(m, src)
}
func (m *Label) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Label) XXX_DiscardUnknown() {
	xxx_messageInfo_Label.DiscardUnknown(m)
}

var xxx_messageInfo_Label proto.InternalMessageInfo

// LabelSet is a collection of labels and their values.
type LabelSet struct {
	// Labels of the set. Instances must be unique and sorted over (Name, Value).
	Labels []Label `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels" yaml:",omitempty"`
}

func (m *LabelSet) Reset()         { *m = LabelSet{} }
func (m *LabelSet) String() string { return proto.CompactTextString(m) }
func (*LabelSet) ProtoMessage()    {}
func (*LabelSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c0999e5af553218, []int{1}
}
func (m *LabelSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LabelSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LabelSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LabelSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LabelSet.Merge(m, src)
}
func (m *LabelSet) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LabelSet) XXX_DiscardUnknown() {
	xxx_messageInfo_LabelSet.DiscardUnknown(m)
}

var xxx_messageInfo_LabelSet proto.InternalMessageInfo

// LabelSelector defines a filter over LabelSets.
type LabelSelector struct {
	// Include is Labels which must be matched for a LabelSet to be selected. If
	// empty, all Labels are included. An include Label with empty ("") value is
	// matched by a Label of the same name having any value.
	Include LabelSet `protobuf:"bytes,1,opt,name=include,proto3" json:"include"`
	// Exclude is Labels which cannot be matched for a LabelSet to be selected. If
	// empty, no Labels are excluded. An exclude Label with empty ("") value
	// excludes a Label of the same name having any value.
	Exclude LabelSet `protobuf:"bytes,2,opt,name=exclude,proto3" json:"exclude"`
}

func (m *LabelSelector) Reset()      { *m = LabelSelector{} }
func (*LabelSelector) ProtoMessage() {}
func (*LabelSelector) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c0999e5af553218, []int{2}
}
func (m *LabelSelector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LabelSelector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LabelSelector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LabelSelector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LabelSelector.Merge(m, src)
}
func (m *LabelSelector) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LabelSelector) XXX_DiscardUnknown() {
	xxx_messageInfo_LabelSelector.DiscardUnknown(m)
}

var xxx_messageInfo_LabelSelector proto.InternalMessageInfo

// JournalSpec describes a Journal and its configuration.
type JournalSpec struct {
	// Name of the Journal.
	Name Journal `protobuf:"bytes,1,opt,name=name,proto3,casttype=Journal" json:"name,omitempty" yaml:",omitempty"`
	// Desired replication of this Journal. This defines the Journal's tolerance
	// to broker failures before data loss can occur (eg, a replication factor
	// of three means two failures are tolerated).
	Replication int32 `protobuf:"varint,2,opt,name=replication,proto3" json:"replication,omitempty" yaml:",omitempty"`
	// User-defined Labels of this JournalSpec. Two label names are reserved
	// and may not be used within a JournalSpec's Labels: "name" and "prefix".
	LabelSet `protobuf:"bytes,3,opt,name=labels,proto3,embedded=labels" json:"labels" yaml:",omitempty,inline"`
	Fragment JournalSpec_Fragment `protobuf:"bytes,4,opt,name=fragment,proto3" json:"fragment" yaml:",omitempty"`
	// Flags of the Journal, as a combination of Flag enum values. The Flag enum
	// is not used directly, as protobuf enums do not allow for or'ed bitfields.
	Flags JournalSpec_Flag `protobuf:"varint,6,opt,name=flags,proto3,casttype=JournalSpec_Flag" json:"flags,omitempty" yaml:",omitempty"`
	// Maximum rate, in bytes-per-second, at which appends of this journal will
	// be processed. If zero (the default), no rate limiting is applied. A global
	// rate limit still may be in effect, in which case the effective rate is the
	// smaller of the journal vs global rate.
	MaxAppendRate int64 `protobuf:"varint,7,opt,name=max_append_rate,json=maxAppendRate,proto3" json:"max_append_rate,omitempty" yaml:"max_append_rate,omitempty"`
}

func (m *JournalSpec) Reset()         { *m = JournalSpec{} }
func (m *JournalSpec) String() string { return proto.CompactTextString(m) }
func (*JournalSpec) ProtoMessage()    {}
func (*JournalSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c0999e5af553218, []int{3}
}
func (m *JournalSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JournalSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JournalSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JournalSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JournalSpec.Merge(m, src)
}
func (m *JournalSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *JournalSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_JournalSpec.DiscardUnknown(m)
}

var xxx_messageInfo_JournalSpec proto.InternalMessageInfo

// Fragment is JournalSpec configuration which pertains to the creation,
// persistence, and indexing of the Journal's Fragments.
type JournalSpec_Fragment struct {
	// Target content length of each Fragment. In normal operation after
	// Fragments reach at least this length, they will be closed and new ones
	// begun. Note lengths may be smaller at times (eg, due to changes in
	// Journal routing topology). Content length differs from Fragment file
	// size, in that the former reflects uncompressed bytes.
	Length int64 `protobuf:"varint,1,opt,name=length,proto3" json:"length,omitempty" yaml:",omitempty"`
	// Codec used to compress Journal Fragments.
	CompressionCodec CompressionCodec `protobuf:"varint,2,opt,name=compression_codec,json=compressionCodec,proto3,enum=protocol.CompressionCodec" json:"compression_codec,omitempty" yaml:"compression_codec,omitempty"`
	// Storage backend base path for this Journal's Fragments. Must be in URL
	// form, with the choice of backend defined by the scheme. The full path of
	// a Journal's Fragment is derived by joining the store path with the
	// Fragment's ContentPath. Eg, given a fragment_store of
	//   "s3://My-AWS-bucket/a/prefix" and a JournalSpec of name "my/journal",
	// a complete Fragment path might be:
	//   "s3://My-AWS-bucket/a/prefix/my/journal/000123-000456-789abcdef.gzip
	//
	// Multiple stores may be specified, in which case the Journal's Fragments
	// are the union of all Fragments present across all stores, and new
	// Fragments always persist to the first specified store. This can be
	// helpful in performing incremental migrations, where new Journal content
	// is written to the new store, while content in the old store remains
	// available (and, depending on fragment_retention or recovery log pruning,
	// may eventually be removed).
	//
	// If no stores are specified, the Journal is still use-able but will
	// not persist Fragments to any a backing fragment store. This allows for
	// real-time streaming use cases where reads of historical data are not
	// needed.
	Stores []FragmentStore `protobuf:"bytes,3,rep,name=stores,proto3,casttype=FragmentStore" json:"stores,omitempty" yaml:",omitempty"`
	// Interval of time between refreshes of remote Fragment listings from
	// configured fragment_stores.
	RefreshInterval time.Duration `protobuf:"bytes,4,opt,name=refresh_interval,json=refreshInterval,proto3,stdduration" json:"refresh_interval" yaml:"refresh_interval,omitempty"`
	// Retention duration for historical Fragments of this Journal within the
	// Fragment stores. If less than or equal to zero, Fragments are retained
	// indefinitely.
	Retention time.Duration `protobuf:"bytes,5,opt,name=retention,proto3,stdduration" json:"retention" yaml:",omitempty"`
	// Flush interval defines a uniform UTC time segment which, when passed,
	// will prompt brokers to close and persist a fragment presently being
	// written.
	//
	// Flush interval may be helpful in integrating the journal with a regularly
	// scheduled batch work-flow which processes new files from the fragment
	// store and has no particular awareness of Gazette. For example, setting
	// flush_interval to 3600s will cause brokers to persist their present
	// fragment on the hour, every hour, even if it has not yet reached its
	// target length. A batch work-flow running at 5 minutes past the hour is
	// then reasonably assured of seeing all events from the past hour.
	//
	// See also "gazctl journals fragments --help" for more discussion.
	FlushInterval time.Duration `protobuf:"bytes,6,opt,name=flush_interval,json=flushInterval,proto3,stdduration" json:"flush_interval" yaml:"flush_interval,omitempty"`
	// Path postfix template is a Go template which evaluates to a partial
	// path under which fragments are persisted to the store. A complete
	// fragment path is constructed by appending path components from the
	// fragment store, then the journal name, and then the postfix template.
	// Path post-fixes can help in maintaining Hive compatible partitioning
	// over fragment creation time. The fields ".Spool" and ".JournalSpec"
	// are available for introspection in the template. For example,
	// to partition on the UTC date and hour of creation, use:
	//
	//    date={{ .Spool.FirstAppendTime.Format "2006-01-02" }}/hour={{
	//    .Spool.FirstAppendTime.Format "15" }}
	//
	// Which will produce a path postfix like "date=2019-11-19/hour=22".
	PathPostfixTemplate string `protobuf:"bytes,7,opt,name=path_postfix_template,json=pathPostfixTemplate,proto3" json:"path_postfix_template,omitempty" yaml:"path_postfix_template,omitempty"`
}

func (m *JournalSpec_Fragment) Reset()         { *m = JournalSpec_Fragment{} }
func (m *JournalSpec_Fragment) String() string { return proto.CompactTextString(m) }
func (*JournalSpec_Fragment) ProtoMessage()    {}
func (*JournalSpec_Fragment) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c0999e5af553218, []int{3, 0}
}
func (m *JournalSpec_Fragment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JournalSpec_Fragment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JournalSpec_Fragment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JournalSpec_Fragment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JournalSpec_Fragment.Merge(m, src)
}
func (m *JournalSpec_Fragment) XXX_Size() int {
	return m.ProtoSize()
}
func (m *JournalSpec_Fragment) XXX_DiscardUnknown() {
	xxx_messageInfo_JournalSpec_Fragment.DiscardUnknown(m)
}

var xxx_messageInfo_JournalSpec_Fragment proto.InternalMessageInfo

// ProcessSpec describes a uniquely identified process and its addressable
// endpoint.
type ProcessSpec struct {
	Id ProcessSpec_ID `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	// Advertised URL of the process.
	Endpoint Endpoint `protobuf:"bytes,2,opt,name=endpoint,proto3,casttype=Endpoint" json:"endpoint,omitempty"`
}

func (m *ProcessSpec) Reset()         { *m = ProcessSpec{} }
func (m *ProcessSpec) String() string { return proto.CompactTextString(m) }
func (*ProcessSpec) ProtoMessage()    {}
func (*ProcessSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c0999e5af553218, []int{4}
}
func (m *ProcessSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProcessSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProcessSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessSpec.Merge(m, src)
}
func (m *ProcessSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ProcessSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessSpec proto.InternalMessageInfo

func (m *ProcessSpec) GetId() ProcessSpec_ID {
	if m != nil {
		return m.Id
	}
	return ProcessSpec_ID{}
}

func (m *ProcessSpec) GetEndpoint() Endpoint {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

// ID composes a zone and a suffix to uniquely identify a ProcessSpec.
type ProcessSpec_ID struct {
	// "Zone" in which the process is running. Zones may be AWS, Azure, or
	// Google Cloud Platform zone identifiers, or rack locations within a colo,
	// or given some other custom meaning. Gazette will replicate across
	// multiple zones, and seeks to minimize traffic which must cross zones (for
	// example, by proxying reads to a broker in the current zone).
	Zone string `protobuf:"bytes,1,opt,name=zone,proto3" json:"zone,omitempty"`
	// Unique suffix of the process within |zone|. It is permissible for a
	// suffix value to repeat across zones, but never within zones. In practice,
	// it's recommended to use a FQDN, Kubernetes Pod name, or comparable unique
	// and self-describing value as the ID suffix.
	Suffix string `protobuf:"bytes,2,opt,name=suffix,proto3" json:"suffix,omitempty"`
}

func (m *ProcessSpec_ID) Reset()         { *m = ProcessSpec_ID{} }
func (m *ProcessSpec_ID) String() string { return proto.CompactTextString(m) }
func (*ProcessSpec_ID) ProtoMessage()    {}
func (*ProcessSpec_ID) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c0999e5af553218, []int{4, 0}
}
func (m *ProcessSpec_ID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessSpec_ID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProcessSpec_ID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProcessSpec_ID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessSpec_ID.Merge(m, src)
}
func (m *ProcessSpec_ID) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ProcessSpec_ID) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessSpec_ID.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessSpec_ID proto.InternalMessageInfo

// BrokerSpec describes a Gazette broker and its configuration.
type BrokerSpec struct {
	// ProcessSpec of the broker.
	ProcessSpec `protobuf:"bytes,1,opt,name=process_spec,json=processSpec,proto3,embedded=process_spec" json:"process_spec" yaml:",inline"`
	// Maximum number of assigned Journal replicas.
	JournalLimit uint32 `protobuf:"varint,2,opt,name=journal_limit,json=journalLimit,proto3" json:"journal_limit,omitempty"`
}

func (m *BrokerSpec) Reset()         { *m = BrokerSpec{} }
func (m *BrokerSpec) String() string { return proto.CompactTextString(m) }
func (*BrokerSpec) ProtoMessage()    {}
func (*BrokerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c0999e5af553218, []int{5}
}
func (m *BrokerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BrokerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BrokerSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BrokerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BrokerSpec.Merge(m, src)
}
func (m *BrokerSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *BrokerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_BrokerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_BrokerSpec proto.InternalMessageInfo

// Fragment is a content-addressed description of a contiguous Journal span,
// defined by the [begin, end) offset range covered by the Fragment and the
// SHA1 sum of the corresponding Journal content.
type Fragment struct {
	// Journal of the Fragment.
	Journal Journal `protobuf:"bytes,1,opt,name=journal,proto3,casttype=Journal" json:"journal,omitempty"`
	// Begin (inclusive) and end (exclusive) offset of the Fragment within the
	// Journal.
	Begin Offset `protobuf:"varint,2,opt,name=begin,proto3,casttype=Offset" json:"begin,omitempty"`
	End   Offset `protobuf:"varint,3,opt,name=end,proto3,casttype=Offset" json:"end,omitempty"`
	// SHA1 sum of the Fragment's content.
	Sum SHA1Sum `protobuf:"bytes,4,opt,name=sum,proto3" json:"sum"`
	// Codec with which the Fragment's content is compressed.
	CompressionCodec CompressionCodec `protobuf:"varint,5,opt,name=compression_codec,json=compressionCodec,proto3,enum=protocol.CompressionCodec" json:"compression_codec,omitempty"`
	// Fragment store which backs the Fragment. Empty if the Fragment has yet to
	// be persisted and is still local to a Broker.
	BackingStore FragmentStore `protobuf:"bytes,6,opt,name=backing_store,json=backingStore,proto3,casttype=FragmentStore" json:"backing_store,omitempty"`
	// Modification timestamp of the Fragment within the backing store,
	// represented as seconds since the epoch.
	ModTime int64 `protobuf:"varint,7,opt,name=mod_time,json=modTime,proto3" json:"mod_time,omitempty"`
	// Path postfix under which the fragment is persisted to the store.
	// The complete Fragment store path is built from any path components of the
	// backing store, followed by the journal name, followed by the path postfix.
	PathPostfix string `protobuf:"bytes,8,opt,name=path_postfix,json=pathPostfix,proto3" json:"path_postfix,omitempty"`
}

func (m *Fragment) Reset()         { *m = Fragment{} }
func (m *Fragment) String() string { return proto.CompactTextString(m) }
func (*Fragment) ProtoMessage()    {}
func (*Fragment) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c0999e5af553218, []int{6}
}
func (m *Fragment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Fragment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Fragment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Fragment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Fragment.Merge(m, src)
}
func (m *Fragment) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Fragment) XXX_DiscardUnknown() {
	xxx_messageInfo_Fragment.DiscardUnknown(m)
}

var xxx_messageInfo_Fragment proto.InternalMessageInfo

// SHA1Sum is a 160-bit SHA1 digest.
type SHA1Sum struct {
	Part1 uint64 `protobuf:"fixed64,1,opt,name=part1,proto3" json:"part1,omitempty"`
	Part2 uint64 `protobuf:"fixed64,2,opt,name=part2,proto3" json:"part2,omitempty"`
	Part3 uint32 `protobuf:"fixed32,3,opt,name=part3,proto3" json:"part3,omitempty"`
}

func (m *SHA1Sum) Reset()         { *m = SHA1Sum{} }
func (m *SHA1Sum) String() string { return proto.CompactTextString(m) }
func (*SHA1Sum) ProtoMessage()    {}
func (*SHA1Sum) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c0999e5af553218, []int{7}
}
func (m *SHA1Sum) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SHA1Sum) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SHA1Sum.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SHA1Sum) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SHA1Sum.Merge(m, src)
}
func (m *SHA1Sum) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SHA1Sum) XXX_DiscardUnknown() {
	xxx_messageInfo_SHA1Sum.DiscardUnknown(m)
}

var xxx_messageInfo_SHA1Sum proto.InternalMessageInfo

// ReadRequest is the unary request message of the broker Read RPC.
type ReadRequest struct {
	// Header is attached by a proxying broker peer.
	Header *Header `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// Journal to be read.
	Journal Journal `protobuf:"bytes,2,opt,name=journal,proto3,casttype=Journal" json:"journal,omitempty"`
	// Desired offset to begin reading from. Value -1 has special handling, where
	// the read is performed from the current write head. All other positive
	// values specify a desired exact byte offset to read from. If the offset is
	// not available (eg, because it represents a portion of Journal which has
	// been permanently deleted), the broker will return the next available
	// offset. Callers should therefore always inspect the ReadResponse offset.
	Offset Offset `protobuf:"varint,3,opt,name=offset,proto3,casttype=Offset" json:"offset,omitempty"`
	// Whether the operation should block until content becomes available.
	// OFFSET_NOT_YET_AVAILABLE is returned if a non-blocking read has no ready
	// content.
	Block bool `protobuf:"varint,4,opt,name=block,proto3" json:"block,omitempty"`
	// If do_not_proxy is true, the broker will not proxy the read to another
	// broker, or open and proxy a remote Fragment on the client's behalf.
	DoNotProxy bool `protobuf:"varint,5,opt,name=do_not_proxy,json=doNotProxy,proto3" json:"do_not_proxy,omitempty"`
	// If metadata_only is true, the broker will respond with Journal and
	// Fragment metadata but not content.
	MetadataOnly bool `protobuf:"varint,6,opt,name=metadata_only,json=metadataOnly,proto3" json:"metadata_only,omitempty"`
	// Offset to read through. If zero, then the read end offset is unconstrained.
	EndOffset Offset `protobuf:"varint,7,opt,name=end_offset,json=endOffset,proto3,casttype=Offset" json:"end_offset,omitempty"`
}

func (m *ReadRequest) Reset()         { *m = ReadRequest{} }
func (m *ReadRequest) String() string { return proto.CompactTextString(m) }
func (*ReadRequest) ProtoMessage()    {}
func (*ReadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c0999e5af553218, []int{8}
}
func (m *ReadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadRequest.Merge(m, src)
}
func (m *ReadRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ReadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReadRequest proto.InternalMessageInfo

// ReadResponse is the streamed response message of the broker Read RPC.
// Responses messages are of two types:
//
// * "Metadata" messages, which conveys the journal Fragment addressed by the
//    request which is ready to be read.
// * "Chunk" messages, which carry associated journal Fragment content bytes.
//
// A metadata message specifying a Fragment always precedes all "chunks" of the
// Fragment's content. Response streams may be very long lived, having many
// metadata and accompanying chunk messages. The reader may also block for long
// periods of time awaiting the next metadata message (eg, if the next offset
// hasn't yet committed). However once a metadata message is read, the reader
// is assured that its associated chunk messages are immediately forthcoming.
type ReadResponse struct {
	// Status of the Read RPC.
	Status Status `protobuf:"varint,1,opt,name=status,proto3,enum=protocol.Status" json:"status,omitempty"`
	// Header of the response. Accompanies the first ReadResponse of the response
	// stream.
	Header *Header `protobuf:"bytes,2,opt,name=header,proto3" json:"header,omitempty"`
	// The effective offset of the read. See ReadRequest offset.
	Offset Offset `protobuf:"varint,3,opt,name=offset,proto3,casttype=Offset" json:"offset,omitempty"`
	// The offset to next be written, by the next append transaction served by
	// broker. In other words, the last offset through which content is
	// available to be read from the Journal. This is a metadata field and will
	// not be returned with a content response.
	WriteHead Offset `protobuf:"varint,4,opt,name=write_head,json=writeHead,proto3,casttype=Offset" json:"write_head,omitempty"`
	// Fragment to which the offset was mapped. This is a metadata field and will
	// not be returned with a content response.
	Fragment *Fragment `protobuf:"bytes,5,opt,name=fragment,proto3" json:"fragment,omitempty"`
	// If Fragment is remote, a URL from which it may be directly read.
	FragmentUrl string `protobuf:"bytes,6,opt,name=fragment_url,json=fragmentUrl,proto3" json:"fragment_url,omitempty"`
	// Content chunks of the read.
	Content []byte `protobuf:"bytes,7,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *ReadResponse) Reset()         { *m = ReadResponse{} }
func (m *ReadResponse) String() string { return proto.CompactTextString(m) }
func (*ReadResponse) ProtoMessage()    {}
func (*ReadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c0999e5af553218, []int{9}
}
func (m *ReadResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadResponse.Merge(m, src)
}
func (m *ReadResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ReadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReadResponse proto.InternalMessageInfo

// AppendRequest is the streamed request message of the broker Append RPC.
// Append request streams consist of an initial message having all parameters
// of the append, such as the journal to append to and preconditions, followed
// by an unbounded number of messages having only content "chunks".
//
// It's not required that the appender know the append size when starting the
// Append RPC -- rather, the client indicates the stream is complete by sending
// a final, empty "chunk" message. However be aware that the broker will
// aggressively time out stalled Append clients, and clients should not start
// RPCs until all content chunks are available for immediate writing.
//
// Append RPCs also expose a concept of journal "registers": LabelSets
// which participate in the journal's transactional append machinery.
// Note that registers are sent and verified with every replicated journal
// transaction, so they're _really_ intended to be very small.
//
// Append RPCs may upsert (union) or delete (subtract) labels from the
// journal's registers. Register consensus is achieved by piggy-backing on the
// append itself: if peers disagree, the registers of the replica having the
// largest journal byte offset always win. For this reason, only RPCs appending
// at least one byte may modify registers.
//
// Append RPCs may also require that registers match an arbitrary selector
// before the RPC may proceed. For example, a write fence can be implemented
// by requiring that a "author" register is of an expected value. At-most-once
// semantics can be implemented as a check-and-set over a single register.
//
// Also be aware that a register update can still occur even for RPCs which are
// reported as failed to the client. That's because an append RPC succeeds
// only after all replicas acknowledge it, but a RPC which applies to some
// replicas but not all still moves the journal offset forward, and therefore
// updates journal registers.
type AppendRequest struct {
	// Header is attached by a proxying broker peer to the first AppendRequest
	// message.
	Header *Header `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// Journal to be appended to.
	Journal Journal `protobuf:"bytes,2,opt,name=journal,proto3,casttype=Journal" json:"journal,omitempty"`
	// If do_not_proxy is true, the broker will not proxy the append if it is
	// not the current primary.
	DoNotProxy bool `protobuf:"varint,3,opt,name=do_not_proxy,json=doNotProxy,proto3" json:"do_not_proxy,omitempty"`
	// Journal offset at which the append should begin. Most clients should leave
	// at zero, which uses the broker's tracked offset. The append offset must be
	// one greater than furthest written offset of the journal, or
	// WRONG_APPEND_OFFSET is returned.
	Offset Offset `protobuf:"varint,5,opt,name=offset,proto3,casttype=Offset" json:"offset,omitempty"`
	// Selector of journal registers which must be satisfied for the request
	// to proceed. If not matched, the RPC is failed with REGISTER_MISMATCH.
	//
	// There's one important exception: if the set of registers associated with
	// a journal is completely empty, then *any* selector is considered as
	// matching. While perhaps surprising, this behavior supports the intended
	// use of registers for cooperative locking, whereby an empty set of
	// registers can be thought of as an "unlocked" state. More practically, if
	// Etcd consensus is lost then so are current register values: on recovery
	// journals will restart with an empty set. This behavior ensures that an
	// existing process holding a prior lock can continue to write -- at least
	// until another process updates registers once again.
	CheckRegisters *LabelSelector `protobuf:"bytes,6,opt,name=check_registers,json=checkRegisters,proto3" json:"check_registers,omitempty"`
	// Labels to union with current registers if the RPC succeeds and appended
	// at least one byte.
	UnionRegisters *LabelSet `protobuf:"bytes,7,opt,name=union_registers,json=unionRegisters,proto3" json:"union_registers,omitempty"`
	// Labels to subtract from current registers if the RPC succeeds and appended
	// at least one byte.
	SubtractRegisters *LabelSet `protobuf:"bytes,8,opt,name=subtract_registers,json=subtractRegisters,proto3" json:"subtract_registers,omitempty"`
	// Content chunks to be appended. Immediately prior to closing the stream,
	// the client must send an empty chunk (eg, zero-valued AppendRequest) to
	// indicate the Append should be committed. Absence of this empty chunk
	// prior to EOF is interpreted by the broker as a rollback of the Append.
	Content []byte `protobuf:"bytes,4,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *AppendRequest) Reset()         { *m = AppendRequest{} }
func (m *AppendRequest) String() string { return proto.CompactTextString(m) }
func (*AppendRequest) ProtoMessage()    {}
func (*AppendRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c0999e5af553218, []int{10}
}
func (m *AppendRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppendRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendRequest.Merge(m, src)
}
func (m *AppendRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AppendRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AppendRequest proto.InternalMessageInfo

// AppendResponse is the unary response message of the broker Append RPC.
type AppendResponse struct {
	// Status of the Append RPC.
	Status Status `protobuf:"varint,1,opt,name=status,proto3,enum=protocol.Status" json:"status,omitempty"`
	// Header of the response.
	Header Header `protobuf:"bytes,2,opt,name=header,proto3" json:"header"`
	// If status is OK, then |commit| is the Fragment which places the
	// committed Append content within the Journal.
	Commit *Fragment `protobuf:"bytes,3,opt,name=commit,proto3" json:"commit,omitempty"`
	// Current registers of the journal.
	Registers *LabelSet `protobuf:"bytes,4,opt,name=registers,proto3" json:"registers,omitempty"`
	// Total number of RPC content chunks processed in this append.
	TotalChunks int64 `protobuf:"varint,5,opt,name=total_chunks,json=totalChunks,proto3" json:"total_chunks,omitempty"`
	// Number of content chunks which were delayed by journal flow control.
	DelayedChunks int64 `protobuf:"varint,6,opt,name=delayed_chunks,json=delayedChunks,proto3" json:"delayed_chunks,omitempty"`
}

func (m *AppendResponse) Reset()         { *m = AppendResponse{} }
func (m *AppendResponse) String() string { return proto.CompactTextString(m) }
func (*AppendResponse) ProtoMessage()    {}
func (*AppendResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c0999e5af553218, []int{11}
}
func (m *AppendResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppendResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendResponse.Merge(m, src)
}
func (m *AppendResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AppendResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AppendResponse proto.InternalMessageInfo

// ReplicateRequest is the streamed request message of the broker's internal
// Replicate RPC. Each message is either a pending content chunk or a
// "proposal" to commit (or roll back) content chunks previously sent.
type ReplicateRequest struct {
	// Header defines the primary broker, Route, and Etcd Revision under which
	// this Replicate stream is being established. Each replication peer
	// independently inspects and verifies the current Journal Route topology.
	Header *Header `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// Proposed Fragment to commit, which is verified by each replica.
	Proposal *Fragment `protobuf:"bytes,3,opt,name=proposal,proto3" json:"proposal,omitempty"`
	// Registers proposed to apply, which are also verified by each replica.
	Registers *LabelSet `protobuf:"bytes,7,opt,name=registers,proto3" json:"registers,omitempty"`
	// Acknowledge requests that the peer send an acknowledging ReplicateResponse
	// on successful application of the ReplicateRequest.
	Acknowledge bool `protobuf:"varint,6,opt,name=acknowledge,proto3" json:"acknowledge,omitempty"`
	// Journal to be replicated to, which is also captured by |proposal|.
	// Deprecated.
	DeprecatedJournal Journal `protobuf:"bytes,2,opt,name=deprecated_journal,json=deprecatedJournal,proto3,casttype=Journal" json:"deprecated_journal,omitempty"`
	// Content to be replicated.
	Content []byte `protobuf:"bytes,4,opt,name=content,proto3" json:"content,omitempty"`
	// Delta offset of |content| relative to current Fragment |end|.
	ContentDelta int64 `protobuf:"varint,5,opt,name=content_delta,json=contentDelta,proto3" json:"content_delta,omitempty"`
}

func (m *ReplicateRequest) Reset()         { *m = ReplicateRequest{} }
func (m *ReplicateRequest) String() string { return proto.CompactTextString(m) }
func (*ReplicateRequest) ProtoMessage()    {}
func (*ReplicateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c0999e5af553218, []int{12}
}
func (m *ReplicateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplicateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplicateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicateRequest.Merge(m, src)
}
func (m *ReplicateRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ReplicateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicateRequest proto.InternalMessageInfo

// ReplicateResponse is the streamed response message of the broker's internal
// Replicate RPC. Each message is a 1:1 response to a previously read "proposal"
// ReplicateRequest with |acknowledge| set.
type ReplicateResponse struct {
	// Status of the Replicate RPC.
	Status Status `protobuf:"varint,1,opt,name=status,proto3,enum=protocol.Status" json:"status,omitempty"`
	// Header of the response. Accompanies the first ReplicateResponse of the
	// response stream.
	Header *Header `protobuf:"bytes,2,opt,name=header,proto3" json:"header,omitempty"`
	// If status is PROPOSAL_MISMATCH, then |fragment| is the replica's current
	// journal Fragment, and either it or |registers| will differ from the
	// primary's proposal.
	Fragment *Fragment `protobuf:"bytes,3,opt,name=fragment,proto3" json:"fragment,omitempty"`
	// If status is PROPOSAL_MISMATCH, then |registers| are the replica's current
	// journal registers.
	Registers *LabelSet `protobuf:"bytes,4,opt,name=registers,proto3" json:"registers,omitempty"`
}

func (m *ReplicateResponse) Reset()         { *m = ReplicateResponse{} }
func (m *ReplicateResponse) String() string { return proto.CompactTextString(m) }
func (*ReplicateResponse) ProtoMessage()    {}
func (*ReplicateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c0999e5af553218, []int{13}
}
func (m *ReplicateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplicateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplicateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicateResponse.Merge(m, src)
}
func (m *ReplicateResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ReplicateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicateResponse proto.InternalMessageInfo

// ListRequest is the unary request message of the broker List RPC.
type ListRequest struct {
	// Selector optionally refines the set of journals which will be enumerated.
	// If zero-valued, all journals are returned. Otherwise, only JournalSpecs
	// matching the LabelSelector will be returned. Two meta-labels "name" and
	// "prefix" are additionally supported by the selector, where:
	//   * name=examples/a-name will match a JournalSpec with Name
	//   "examples/a-name"
	//   * prefix=examples/ will match any JournalSpec having prefix "examples/".
	//     The prefix Label value must end in '/'.
	Selector LabelSelector `protobuf:"bytes,1,opt,name=selector,proto3" json:"selector"`
}

func (m *ListRequest) Reset()         { *m = ListRequest{} }
func (m *ListRequest) String() string { return proto.CompactTextString(m) }
func (*ListRequest) ProtoMessage()    {}
func (*ListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c0999e5af553218, []int{14}
}
func (m *ListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRequest.Merge(m, src)
}
func (m *ListRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListRequest proto.InternalMessageInfo

// ListResponse is the unary response message of the broker List RPC.
type ListResponse struct {
	// Status of the List RPC.
	Status Status `protobuf:"varint,1,opt,name=status,proto3,enum=protocol.Status" json:"status,omitempty"`
	// Header of the response.
	Header   Header                 `protobuf:"bytes,2,opt,name=header,proto3" json:"header"`
	Journals []ListResponse_Journal `protobuf:"bytes,3,rep,name=journals,proto3" json:"journals"`
}

func (m *ListResponse) Reset()         { *m = ListResponse{} }
func (m *ListResponse) String() string { return proto.CompactTextString(m) }
func (*ListResponse) ProtoMessage()    {}
func (*ListResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c0999e5af553218, []int{15}
}
func (m *ListResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListResponse.Merge(m, src)
}
func (m *ListResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ListResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListResponse proto.InternalMessageInfo

// Journals of the response.
type ListResponse_Journal struct {
	Spec JournalSpec `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec"`
	// Current ModRevision of the JournalSpec.
	ModRevision int64 `protobuf:"varint,2,opt,name=mod_revision,json=modRevision,proto3" json:"mod_revision,omitempty"`
	// Route of the journal, including endpoints.
	Route Route `protobuf:"bytes,3,opt,name=route,proto3" json:"route"`
}

func (m *ListResponse_Journal) Reset()         { *m = ListResponse_Journal{} }
func (m *ListResponse_Journal) String() string { return proto.CompactTextString(m) }
func (*ListResponse_Journal) ProtoMessage()    {}
func (*ListResponse_Journal) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c0999e5af553218, []int{15, 0}
}
func (m *ListResponse_Journal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListResponse_Journal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListResponse_Journal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListResponse_Journal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListResponse_Journal.Merge(m, src)
}
func (m *ListResponse_Journal) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ListResponse_Journal) XXX_DiscardUnknown() {
	xxx_messageInfo_ListResponse_Journal.DiscardUnknown(m)
}

var xxx_messageInfo_ListResponse_Journal proto.InternalMessageInfo

// ApplyRequest is the unary request message of the broker Apply RPC.
type ApplyRequest struct {
	Changes []ApplyRequest_Change `protobuf:"bytes,1,rep,name=changes,proto3" json:"changes"`
}

func (m *ApplyRequest) Reset()         { *m = ApplyRequest{} }
func (m *ApplyRequest) String() string { return proto.CompactTextString(m) }
func (*ApplyRequest) ProtoMessage()    {}
func (*ApplyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c0999e5af553218, []int{16}
}
func (m *ApplyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyRequest.Merge(m, src)
}
func (m *ApplyRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ApplyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyRequest proto.InternalMessageInfo

// Change defines an insertion, update, or deletion to be applied to the set
// of JournalSpecs. Exactly one of |upsert| or |delete| must be set.
type ApplyRequest_Change struct {
	// Expected ModRevision of the current JournalSpec. If the Journal is being
	// created, expect_mod_revision is zero.
	ExpectModRevision int64 `protobuf:"varint,1,opt,name=expect_mod_revision,json=expectModRevision,proto3" json:"expect_mod_revision,omitempty"`
	// JournalSpec to be updated (if expect_mod_revision > 0) or created
	// (if expect_mod_revision == 0).
	Upsert *JournalSpec `protobuf:"bytes,2,opt,name=upsert,proto3" json:"upsert,omitempty"`
	// Journal to be deleted. expect_mod_revision must not be zero.
	Delete Journal `protobuf:"bytes,3,opt,name=delete,proto3,casttype=Journal" json:"delete,omitempty"`
}

func (m *ApplyRequest_Change) Reset()         { *m = ApplyRequest_Change{} }
func (m *ApplyRequest_Change) String() string { return proto.CompactTextString(m) }
func (*ApplyRequest_Change) ProtoMessage()    {}
func (*ApplyRequest_Change) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c0999e5af553218, []int{16, 0}
}
func (m *ApplyRequest_Change) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyRequest_Change) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyRequest_Change.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyRequest_Change) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyRequest_Change.Merge(m, src)
}
func (m *ApplyRequest_Change) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ApplyRequest_Change) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyRequest_Change.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyRequest_Change proto.InternalMessageInfo

// ApplyResponse is the unary response message of the broker Apply RPC.
type ApplyResponse struct {
	// Status of the Apply RPC.
	Status Status `protobuf:"varint,1,opt,name=status,proto3,enum=protocol.Status" json:"status,omitempty"`
	// Header of the response.
	Header Header `protobuf:"bytes,2,opt,name=header,proto3" json:"header"`
}

func (m *ApplyResponse) Reset()         { *m = ApplyResponse{} }
func (m *ApplyResponse) String() string { return proto.CompactTextString(m) }
func (*ApplyResponse) ProtoMessage()    {}
func (*ApplyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c0999e5af553218, []int{17}
}
func (m *ApplyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyResponse.Merge(m, src)
}
func (m *ApplyResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ApplyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyResponse proto.InternalMessageInfo

// FragmentsRequest is the unary request message of the broker ListFragments
// RPC.
type FragmentsRequest struct {
	// Header is attached by a proxying broker peer.
	Header *Header `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// Journal to be read.
	Journal Journal `protobuf:"bytes,2,opt,name=journal,proto3,casttype=Journal" json:"journal,omitempty"`
	// BeginModTime is an optional field specifying an inclusive lower bound on
	// the modification timestamp for a fragment to be returned. The timestamp is
	// represented as seconds since the epoch.
	BeginModTime int64 `protobuf:"varint,3,opt,name=begin_mod_time,json=beginModTime,proto3" json:"begin_mod_time,omitempty"`
	// EndModTime is an optional field specifying an exclusive upper bound on
	// the modification timestamp for a fragment to be returned. The timestamp is
	// represented as seconds since the epoch.
	EndModTime int64 `protobuf:"varint,4,opt,name=end_mod_time,json=endModTime,proto3" json:"end_mod_time,omitempty"`
	// The NextPageToke value returned from a previous, continued
	// FragmentsRequest, if any.
	NextPageToken int64 `protobuf:"varint,5,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	// PageLimit is an optional field specifying how many fragments to return
	// with the response. The default value for PageLimit is 1000.
	PageLimit int32 `protobuf:"varint,6,opt,name=page_limit,json=pageLimit,proto3" json:"page_limit,omitempty"`
	// SignatureTTL indicates that a temporary signed GET URL should be returned
	// with each response Fragment, valid for |signatureTTL|.
	SignatureTTL *time.Duration `protobuf:"bytes,7,opt,name=signatureTTL,proto3,stdduration" json:"signatureTTL,omitempty"`
	// If do_not_proxy is true, the broker will not proxy the request to another
	// broker on the client's behalf.
	DoNotProxy bool `protobuf:"varint,8,opt,name=do_not_proxy,json=doNotProxy,proto3" json:"do_not_proxy,omitempty"`
}

func (m *FragmentsRequest) Reset()         { *m = FragmentsRequest{} }
func (m *FragmentsRequest) String() string { return proto.CompactTextString(m) }
func (*FragmentsRequest) ProtoMessage()    {}
func (*FragmentsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c0999e5af553218, []int{18}
}
func (m *FragmentsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FragmentsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FragmentsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FragmentsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FragmentsRequest.Merge(m, src)
}
func (m *FragmentsRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *FragmentsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FragmentsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FragmentsRequest proto.InternalMessageInfo

// FragmentsResponse is the unary response message of the broker ListFragments
// RPC.
type FragmentsResponse struct {
	// Status of the Apply RPC.
	Status Status `protobuf:"varint,1,opt,name=status,proto3,enum=protocol.Status" json:"status,omitempty"`
	// Header of the response.
	Header    Header                        `protobuf:"bytes,2,opt,name=header,proto3" json:"header"`
	Fragments []FragmentsResponse__Fragment `protobuf:"bytes,3,rep,name=fragments,proto3" json:"fragments"`
	// The NextPageToke value to be returned on subsequent Fragments requests. If
	// the value is zero then there are no more fragments to be returned for this
	// page.
	NextPageToken int64 `protobuf:"varint,4,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
}

func (m *FragmentsResponse) Reset()         { *m = FragmentsResponse{} }
func (m *FragmentsResponse) String() string { return proto.CompactTextString(m) }
func (*FragmentsResponse) ProtoMessage()    {}
func (*FragmentsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c0999e5af553218, []int{19}
}
func (m *FragmentsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FragmentsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FragmentsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FragmentsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FragmentsResponse.Merge(m, src)
}
func (m *FragmentsResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *FragmentsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FragmentsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FragmentsResponse proto.InternalMessageInfo

// Fragments of the Response.
type FragmentsResponse__Fragment struct {
	Spec Fragment `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec"`
	// SignedURL is a temporary URL at which a direct GET of the Fragment may
	// be issued, signed by the broker's credentials. Set only if the request
	// specified a SignatureTTL.
	SignedUrl string `protobuf:"bytes,2,opt,name=signed_url,json=signedUrl,proto3" json:"signed_url,omitempty"`
}

func (m *FragmentsResponse__Fragment) Reset()         { *m = FragmentsResponse__Fragment{} }
func (m *FragmentsResponse__Fragment) String() string { return proto.CompactTextString(m) }
func (*FragmentsResponse__Fragment) ProtoMessage()    {}
func (*FragmentsResponse__Fragment) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c0999e5af553218, []int{19, 0}
}
func (m *FragmentsResponse__Fragment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FragmentsResponse__Fragment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FragmentsResponse__Fragment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FragmentsResponse__Fragment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FragmentsResponse__Fragment.Merge(m, src)
}
func (m *FragmentsResponse__Fragment) XXX_Size() int {
	return m.ProtoSize()
}
func (m *FragmentsResponse__Fragment) XXX_DiscardUnknown() {
	xxx_messageInfo_FragmentsResponse__Fragment.DiscardUnknown(m)
}

var xxx_messageInfo_FragmentsResponse__Fragment proto.InternalMessageInfo

// Route captures the current topology of an item and the processes serving it.
type Route struct {
	// Members of the Route, ordered on ascending ProcessSpec.ID (zone, suffix).
	Members []ProcessSpec_ID `protobuf:"bytes,1,rep,name=members,proto3" json:"members"`
	// Index of the ProcessSpec serving as primary within |members|,
	// or -1 of no member is currently primary.
	Primary int32 `protobuf:"varint,2,opt,name=primary,proto3" json:"primary,omitempty"`
	// Endpoints of each Route member. If not empty, |endpoints| has the same
	// length and order as |members|, and captures the endpoint of each one.
	Endpoints []Endpoint `protobuf:"bytes,3,rep,name=endpoints,proto3,casttype=Endpoint" json:"endpoints,omitempty"`
}

func (m *Route) Reset()         { *m = Route{} }
func (m *Route) String() string { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()    {}
func (*Route) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c0999e5af553218, []int{20}
}
func (m *Route) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Route) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Route.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Route) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Route.Merge(m, src)
}
func (m *Route) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Route) XXX_DiscardUnknown() {
	xxx_messageInfo_Route.DiscardUnknown(m)
}

var xxx_messageInfo_Route proto.InternalMessageInfo

// Header captures metadata such as the process responsible for processing
// an RPC, and its effective Etcd state.
type Header struct {
	// ID of the process responsible for request processing. May be empty iff
	// Header is being used within a proxied request, and that request may be
	// dispatched to any member of the Route.
	ProcessId ProcessSpec_ID `protobuf:"bytes,1,opt,name=process_id,json=processId,proto3" json:"process_id"`
	// Route of processes specifically responsible for this RPC, or an empty Route
	// if any process is capable of serving the RPC.
	Route Route       `protobuf:"bytes,2,opt,name=route,proto3" json:"route"`
	Etcd  Header_Etcd `protobuf:"bytes,3,opt,name=etcd,proto3" json:"etcd"`
}

func (m *Header) Reset()         { *m = Header{} }
func (m *Header) String() string { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()    {}
func (*Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c0999e5af553218, []int{21}
}
func (m *Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Header.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header.Merge(m, src)
}
func (m *Header) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Header proto.InternalMessageInfo

// Etcd represents the effective Etcd MVCC state under which a Gazette broker
// is operating in its processing of requests and responses. Its inclusion
// allows brokers to reason about relative "happened before" Revision ordering
// of apparent routing conflicts in proxied or replicated requests, as well
// as enabling sanity checks over equality of Etcd ClusterId (and precluding,
// for example, split-brain scenarios where different brokers are backed by
// different Etcd clusters). Etcd is kept in sync with
// etcdserverpb.ResponseHeader.
type Header_Etcd struct {
	// cluster_id is the ID of the cluster.
	ClusterId uint64 `protobuf:"varint,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	// member_id is the ID of the member.
	MemberId uint64 `protobuf:"varint,2,opt,name=member_id,json=memberId,proto3" json:"member_id,omitempty"`
	// revision is the Etcd key-value store revision when the request was
	// applied.
	Revision int64 `protobuf:"varint,3,opt,name=revision,proto3" json:"revision,omitempty"`
	// raft_term is the raft term when the request was applied.
	RaftTerm uint64 `protobuf:"varint,4,opt,name=raft_term,json=raftTerm,proto3" json:"raft_term,omitempty"`
}

func (m *Header_Etcd) Reset()         { *m = Header_Etcd{} }
func (m *Header_Etcd) String() string { return proto.CompactTextString(m) }
func (*Header_Etcd) ProtoMessage()    {}
func (*Header_Etcd) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c0999e5af553218, []int{21, 0}
}
func (m *Header_Etcd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Header_Etcd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Header_Etcd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Header_Etcd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header_Etcd.Merge(m, src)
}
func (m *Header_Etcd) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Header_Etcd) XXX_DiscardUnknown() {
	xxx_messageInfo_Header_Etcd.DiscardUnknown(m)
}

var xxx_messageInfo_Header_Etcd proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("protocol.Status", Status_name, Status_value)
	proto.RegisterEnum("protocol.CompressionCodec", CompressionCodec_name, CompressionCodec_value)
	proto.RegisterEnum("protocol.JournalSpec_Flag", JournalSpec_Flag_name, JournalSpec_Flag_value)
	proto.RegisterType((*Label)(nil), "protocol.Label")
	proto.RegisterType((*LabelSet)(nil), "protocol.LabelSet")
	proto.RegisterType((*LabelSelector)(nil), "protocol.LabelSelector")
	proto.RegisterType((*JournalSpec)(nil), "protocol.JournalSpec")
	proto.RegisterType((*JournalSpec_Fragment)(nil), "protocol.JournalSpec.Fragment")
	proto.RegisterType((*ProcessSpec)(nil), "protocol.ProcessSpec")
	proto.RegisterType((*ProcessSpec_ID)(nil), "protocol.ProcessSpec.ID")
	proto.RegisterType((*BrokerSpec)(nil), "protocol.BrokerSpec")
	proto.RegisterType((*Fragment)(nil), "protocol.Fragment")
	proto.RegisterType((*SHA1Sum)(nil), "protocol.SHA1Sum")
	proto.RegisterType((*ReadRequest)(nil), "protocol.ReadRequest")
	proto.RegisterType((*ReadResponse)(nil), "protocol.ReadResponse")
	proto.RegisterType((*AppendRequest)(nil), "protocol.AppendRequest")
	proto.RegisterType((*AppendResponse)(nil), "protocol.AppendResponse")
	proto.RegisterType((*ReplicateRequest)(nil), "protocol.ReplicateRequest")
	proto.RegisterType((*ReplicateResponse)(nil), "protocol.ReplicateResponse")
	proto.RegisterType((*ListRequest)(nil), "protocol.ListRequest")
	proto.RegisterType((*ListResponse)(nil), "protocol.ListResponse")
	proto.RegisterType((*ListResponse_Journal)(nil), "protocol.ListResponse.Journal")
	proto.RegisterType((*ApplyRequest)(nil), "protocol.ApplyRequest")
	proto.RegisterType((*ApplyRequest_Change)(nil), "protocol.ApplyRequest.Change")
	proto.RegisterType((*ApplyResponse)(nil), "protocol.ApplyResponse")
	proto.RegisterType((*FragmentsRequest)(nil), "protocol.FragmentsRequest")
	proto.RegisterType((*FragmentsResponse)(nil), "protocol.FragmentsResponse")
	proto.RegisterType((*FragmentsResponse__Fragment)(nil), "protocol.FragmentsResponse._Fragment")
	proto.RegisterType((*Route)(nil), "protocol.Route")
	proto.RegisterType((*Header)(nil), "protocol.Header")
	proto.RegisterType((*Header_Etcd)(nil), "protocol.Header.Etcd")
}

func init() { proto.RegisterFile("broker/protocol/protocol.proto", fileDescriptor_0c0999e5af553218) }

var fileDescriptor_0c0999e5af553218 = []byte{
	// 2547 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x59, 0xcd, 0x73, 0xdb, 0xc6,
	0x15, 0x17, 0xbf, 0xc1, 0x47, 0x52, 0x82, 0x36, 0xb1, 0x2d, 0x33, 0xb1, 0xa8, 0x20, 0x1f, 0x23,
	0x3b, 0x09, 0xed, 0x28, 0x6d, 0x93, 0xba, 0x93, 0x36, 0xa4, 0x48, 0xd9, 0x74, 0x68, 0x92, 0xb3,
	0xa4, 0xe2, 0x38, 0x87, 0x62, 0x20, 0x60, 0x45, 0xa1, 0x02, 0x01, 0x14, 0x58, 0x3a, 0x52, 0x3a,
	0x9d, 0xe9, 0xf4, 0x90, 0x76, 0x32, 0x3d, 0x74, 0x7a, 0xca, 0xa9, 0xcd, 0xf4, 0xd4, 0xbf, 0xa1,
	0x9d, 0xde, 0xdd, 0x5b, 0x8e, 0x9d, 0x69, 0xab, 0x4e, 0xed, 0xff, 0xc0, 0xc7, 0x9c, 0x3a, 0xfb,
	0x01, 0x12, 0xa2, 0x48, 0xcb, 0x39, 0xf8, 0x86, 0x7d, 0x5f, 0xfb, 0xf6, 0xbd, 0xb7, 0xbf, 0x7d,
	0x8f, 0x84, 0xf5, 0xbd, 0xc0, 0x3b, 0x24, 0xc1, 0x75, 0x3f, 0xf0, 0xa8, 0x67, 0x7a, 0xce, 0xe4,
	0xa3, 0xca, 0x3f, 0x90, 0x12, 0xad, 0xcb, 0x2f, 0x0e, 0xbd, 0xa1, 0xc7, 0x57, 0xd7, 0xd9, 0x97,
	0xe0, 0x97, 0xd7, 0x7d, 0x7a, 0xec, 0x93, 0xf0, 0xba, 0x35, 0x0e, 0x0c, 0x6a, 0x7b, 0xee, 0xe4,
	0x43, 0xf0, 0xb5, 0x77, 0x20, 0xd3, 0x36, 0xf6, 0x88, 0x83, 0x10, 0xa4, 0x5d, 0x63, 0x44, 0xd6,
	0x12, 0x1b, 0x89, 0xcd, 0x3c, 0xe6, 0xdf, 0xe8, 0x45, 0xc8, 0x3c, 0x30, 0x9c, 0x31, 0x59, 0x4b,
	0x72, 0xa2, 0x58, 0x68, 0x1d, 0x50, 0xb8, 0x4a, 0x9f, 0x50, 0x54, 0x87, 0xac, 0xc3, 0xbe, 0xc3,
	0xb5, 0xc4, 0x46, 0x6a, 0xb3, 0xb0, 0xb5, 0x52, 0x9d, 0xf8, 0xc7, 0x65, 0xea, 0x97, 0x1f, 0x9e,
	0x54, 0x96, 0x9e, 0x9c, 0x54, 0x56, 0x8f, 0x8d, 0x91, 0x73, 0x53, 0x7b, 0xcb, 0x1b, 0xd9, 0x94,
	0x8c, 0x7c, 0x7a, 0xac, 0x61, 0xa9, 0xa9, 0xfd, 0x12, 0x4a, 0xd2, 0x9e, 0x43, 0x4c, 0xea, 0x05,
	0x68, 0x0b, 0x72, 0xb6, 0x6b, 0x3a, 0x63, 0x4b, 0x78, 0x53, 0xd8, 0x42, 0x33, 0x56, 0xfb, 0x84,
	0xd6, 0xd3, 0xcc, 0x30, 0x8e, 0x04, 0x99, 0x0e, 0x39, 0x12, 0x3a, 0xc9, 0xf3, 0x74, 0xa4, 0xe0,
	0xcd, 0xf4, 0x57, 0x5f, 0x57, 0x96, 0xb4, 0x5f, 0xe5, 0xa1, 0x70, 0xc7, 0x1b, 0x07, 0xae, 0xe1,
	0xf4, 0x7d, 0x62, 0xa2, 0xef, 0xc5, 0x03, 0x51, 0xdf, 0x98, 0xeb, 0xfb, 0xb7, 0x27, 0x95, 0x9c,
	0xd4, 0x91, 0xa1, 0x7a, 0x0f, 0x0a, 0x01, 0xf1, 0x1d, 0xdb, 0xe4, 0xc1, 0xe5, 0x3e, 0x64, 0xea,
	0x17, 0xe6, 0x1f, 0x3c, 0x2e, 0x89, 0x7a, 0x93, 0x08, 0xa6, 0x16, 0xfa, 0xfd, 0x1a, 0xf3, 0xfb,
	0x9b, 0x93, 0x4a, 0xe2, 0xc9, 0x49, 0x65, 0x6d, 0xd6, 0xde, 0x5b, 0xb6, 0xeb, 0xd8, 0x2e, 0x99,
	0xc4, 0x13, 0xed, 0x82, 0xb2, 0x1f, 0x18, 0xc3, 0x11, 0x71, 0xe9, 0x5a, 0x9a, 0xdb, 0x5c, 0x9f,
	0xda, 0x8c, 0x9d, 0xb4, 0xba, 0x23, 0xa5, 0x9e, 0x96, 0xa4, 0x89, 0x29, 0xf4, 0x13, 0xc8, 0xec,
	0x3b, 0xc6, 0x30, 0x5c, 0xcb, 0x6e, 0x24, 0x36, 0x4b, 0xf5, 0xab, 0x8b, 0x02, 0xa3, 0xc6, 0xb6,
	0xd0, 0x77, 0x1c, 0x63, 0x88, 0x85, 0x1e, 0x6a, 0xc3, 0xca, 0xc8, 0x38, 0xd2, 0x0d, 0xdf, 0x27,
	0xae, 0xa5, 0x07, 0x06, 0x25, 0x6b, 0xb9, 0x8d, 0xc4, 0x66, 0xaa, 0xfe, 0xda, 0x93, 0x93, 0xca,
	0x86, 0x30, 0x35, 0x23, 0x10, 0xf7, 0xa4, 0x34, 0x32, 0x8e, 0x6a, 0x9c, 0x85, 0x0d, 0x4a, 0xca,
	0x5f, 0x64, 0x40, 0x89, 0x0e, 0x80, 0xde, 0x86, 0xac, 0x43, 0xdc, 0x21, 0x3d, 0xe0, 0x59, 0x4b,
	0x2d, 0x0a, 0xbc, 0x14, 0x42, 0x1e, 0xac, 0x9a, 0xde, 0xc8, 0x0f, 0x48, 0x18, 0xda, 0x9e, 0xab,
	0x9b, 0x9e, 0x45, 0x4c, 0x9e, 0xb2, 0xe5, 0xad, 0xf2, 0x34, 0x54, 0xdb, 0x53, 0x91, 0x6d, 0x26,
	0x51, 0x7f, 0xe3, 0xc9, 0x49, 0x45, 0x13, 0x56, 0xcf, 0xa8, 0xc7, 0xb7, 0x51, 0xcd, 0x19, 0x4d,
	0xf4, 0x63, 0xc8, 0x86, 0xd4, 0x0b, 0x08, 0x4b, 0x72, 0x6a, 0x33, 0xcf, 0x2d, 0xcd, 0x0d, 0x5e,
	0x29, 0x3a, 0x52, 0x9f, 0x89, 0x63, 0xa9, 0x85, 0x42, 0x50, 0x03, 0xb2, 0x1f, 0x90, 0xf0, 0x40,
	0xb7, 0x5d, 0x4a, 0x82, 0x07, 0x86, 0x23, 0x53, 0x7b, 0xb9, 0x3a, 0xf4, 0xbc, 0xa1, 0x43, 0x84,
	0xdb, 0x7b, 0xe3, 0xfd, 0x6a, 0x43, 0x5e, 0xf0, 0xfa, 0xdb, 0x32, 0xab, 0xaf, 0x88, 0x8d, 0x66,
	0x0d, 0xc4, 0x36, 0xfe, 0xea, 0xbf, 0x95, 0x04, 0x5e, 0x91, 0x02, 0x2d, 0xc9, 0x47, 0x1f, 0x43,
	0x3e, 0x20, 0x94, 0xb8, 0xbc, 0xa0, 0x33, 0xe7, 0xed, 0x76, 0x65, 0x61, 0x0d, 0x71, 0xeb, 0x53,
	0x53, 0x68, 0x04, 0xcb, 0xfb, 0xce, 0x38, 0x7e, 0x94, 0xec, 0x79, 0xc6, 0xdf, 0x94, 0xc6, 0x2b,
	0xc2, 0xf8, 0x69, 0xf5, 0xd9, 0xad, 0x4a, 0x9c, 0x3d, 0x39, 0xc6, 0x4f, 0xe1, 0x82, 0x6f, 0xd0,
	0x03, 0xdd, 0xf7, 0x42, 0xba, 0x6f, 0x1f, 0xe9, 0x4c, 0xd4, 0x89, 0x8a, 0x2f, 0x5f, 0xbf, 0xf6,
	0xe4, 0xa4, 0xf2, 0x86, 0x30, 0x3b, 0x57, 0x2c, 0x9e, 0xd8, 0x17, 0x98, 0x44, 0x4f, 0x08, 0x0c,
	0x24, 0x5f, 0xab, 0x41, 0x9a, 0x55, 0x39, 0x5a, 0x85, 0x52, 0xa7, 0x3b, 0xd0, 0xfb, 0xbd, 0xe6,
	0x76, 0x6b, 0xa7, 0xd5, 0x6c, 0xa8, 0x4b, 0xa8, 0x08, 0x4a, 0x57, 0xc7, 0x8d, 0x6e, 0xa7, 0x7d,
	0x5f, 0x4d, 0x88, 0xd5, 0x3d, 0xcc, 0x57, 0x49, 0x04, 0x90, 0x65, 0xbc, 0x7b, 0x58, 0x4d, 0x6b,
	0x7f, 0x4a, 0x40, 0xa1, 0x17, 0x78, 0x26, 0x09, 0x43, 0x0e, 0x41, 0x55, 0x48, 0xda, 0x96, 0xc4,
	0xbe, 0xb5, 0x69, 0x41, 0xc6, 0x44, 0xaa, 0xad, 0x86, 0x44, 0xb3, 0xa4, 0x6d, 0xa1, 0x4d, 0x50,
	0x88, 0x6b, 0xf9, 0x9e, 0xed, 0x52, 0x01, 0xd5, 0xf5, 0xe2, 0xb7, 0x27, 0x15, 0xa5, 0x29, 0x69,
	0x78, 0xc2, 0x2d, 0xdf, 0x80, 0x64, 0xab, 0xc1, 0xb0, 0xfe, 0x73, 0xcf, 0x9d, 0x60, 0x3d, 0xfb,
	0x46, 0x17, 0x21, 0x1b, 0x8e, 0xf7, 0xf7, 0xed, 0x23, 0x09, 0xf6, 0x72, 0x75, 0x33, 0xfd, 0xdb,
	0xaf, 0x2b, 0x09, 0xed, 0x37, 0x09, 0x80, 0x3a, 0x7f, 0x89, 0xb8, 0x83, 0x03, 0x28, 0xfa, 0xc2,
	0x19, 0x3d, 0xf4, 0x89, 0x29, 0x5d, 0xbd, 0x30, 0xd7, 0xd5, 0x7a, 0x39, 0x86, 0x5e, 0xcb, 0xb2,
	0x3a, 0x22, 0xcc, 0x2a, 0xf8, 0xb1, 0x63, 0xbf, 0x0a, 0xa5, 0x9f, 0x09, 0xec, 0xd0, 0x1d, 0x7b,
	0x64, 0x8b, 0xb3, 0x94, 0x70, 0x51, 0x12, 0xdb, 0x8c, 0xa6, 0xfd, 0x2b, 0x19, 0xbb, 0xf7, 0xaf,
	0x43, 0x4e, 0x32, 0x25, 0x5c, 0x17, 0xe2, 0xc8, 0x1c, 0xf1, 0xd0, 0x06, 0x64, 0xf6, 0xc8, 0xd0,
	0x16, 0xb0, 0x9c, 0xaa, 0xc3, 0xb7, 0x27, 0x95, 0x6c, 0x77, 0x7f, 0x3f, 0x24, 0x14, 0x0b, 0x06,
	0x7a, 0x19, 0x52, 0xc4, 0xb5, 0x38, 0x04, 0x9f, 0xe6, 0x33, 0x32, 0xba, 0x0a, 0xa9, 0x70, 0x3c,
	0x92, 0x37, 0x6e, 0x75, 0x7a, 0xca, 0xfe, 0xed, 0xda, 0x3b, 0xfd, 0xf1, 0x48, 0x66, 0x82, 0xc9,
	0xa0, 0x5b, 0xf3, 0xa0, 0x25, 0x73, 0x1e, 0xb4, 0xcc, 0x81, 0x8c, 0x1f, 0x40, 0x69, 0xcf, 0x30,
	0x0f, 0x6d, 0x77, 0xa8, 0x73, 0x10, 0xe0, 0x97, 0x24, 0x5f, 0x5f, 0x3d, 0x0b, 0x12, 0x45, 0x29,
	0xc7, 0x57, 0xe8, 0x32, 0x28, 0x23, 0xcf, 0xd2, 0xa9, 0x3d, 0x92, 0xf0, 0x8a, 0x73, 0x23, 0xcf,
	0x1a, 0xd8, 0x23, 0x82, 0x5e, 0x81, 0x62, 0xbc, 0xc4, 0xd7, 0x14, 0x9e, 0xe8, 0x42, 0xac, 0xa8,
	0xb5, 0x8f, 0x20, 0x27, 0x0f, 0xc5, 0x1e, 0x7f, 0xdf, 0x08, 0xe8, 0x3b, 0x3c, 0xb2, 0x59, 0x2c,
	0x16, 0x11, 0x75, 0x8b, 0x87, 0x52, 0x52, 0xb7, 0x22, 0xea, 0xbb, 0x3c, 0x80, 0x39, 0x41, 0x7d,
	0x57, 0xfb, 0x32, 0x09, 0x05, 0x4c, 0x0c, 0x0b, 0x93, 0x9f, 0x8f, 0x49, 0x48, 0xd1, 0x26, 0x64,
	0x0f, 0x88, 0x61, 0x91, 0x40, 0xd6, 0x8b, 0x3a, 0x0d, 0xc8, 0x6d, 0x4e, 0xc7, 0x92, 0x1f, 0xcf,
	0x6b, 0xf2, 0x29, 0x79, 0xd5, 0x20, 0xeb, 0xf1, 0x34, 0xcd, 0x49, 0x9c, 0xe4, 0x30, 0xd7, 0xf6,
	0x1c, 0xcf, 0x3c, 0xe4, 0xd9, 0x53, 0xb0, 0x58, 0xa0, 0x0d, 0x28, 0x5a, 0x9e, 0xee, 0x7a, 0x54,
	0xf7, 0x03, 0xef, 0xe8, 0x98, 0x67, 0x48, 0xc1, 0x60, 0x79, 0x1d, 0x8f, 0xf6, 0x18, 0x85, 0x15,
	0xe3, 0x88, 0x50, 0xc3, 0x32, 0xa8, 0xa1, 0x7b, 0xae, 0x73, 0xcc, 0xe3, 0xaf, 0xe0, 0x62, 0x44,
	0xec, 0xba, 0xce, 0x31, 0xba, 0x0a, 0xc0, 0x9e, 0x2a, 0xe9, 0x44, 0xee, 0x8c, 0x13, 0x79, 0xe2,
	0x5a, 0xe2, 0x53, 0xfb, 0x63, 0x12, 0x8a, 0x22, 0x18, 0xa1, 0xef, 0xb9, 0x21, 0x61, 0xd1, 0x08,
	0xa9, 0x41, 0xc7, 0x21, 0x8f, 0xc6, 0x72, 0x3c, 0x1a, 0x7d, 0x4e, 0xc7, 0x92, 0x1f, 0x8b, 0x5b,
	0xf2, 0x9c, 0xb8, 0x3d, 0x4b, 0x40, 0xae, 0x02, 0x7c, 0x16, 0xd8, 0x94, 0xe8, 0x4c, 0x87, 0x47,
	0x65, 0xc6, 0x67, 0xce, 0x65, 0x86, 0x51, 0x35, 0xd6, 0x49, 0x64, 0x66, 0xbb, 0x93, 0xa8, 0x08,
	0x63, 0x2d, 0xc2, 0x2b, 0x50, 0x8c, 0xbe, 0xf5, 0x71, 0x20, 0x70, 0x3d, 0x8f, 0x0b, 0x11, 0x6d,
	0x37, 0x70, 0xd0, 0x1a, 0xe4, 0x4c, 0xcf, 0x65, 0x4f, 0x01, 0x0f, 0x57, 0x11, 0x47, 0x4b, 0xed,
	0xd7, 0x29, 0x28, 0xc9, 0xf7, 0xfd, 0x79, 0xd5, 0xcb, 0x6c, 0xd6, 0x53, 0x67, 0xb2, 0x3e, 0x0d,
	0x60, 0x66, 0x61, 0x00, 0x3f, 0x84, 0x15, 0xf3, 0x80, 0x98, 0x87, 0x7a, 0x40, 0x86, 0x76, 0x48,
	0x49, 0x10, 0xca, 0x07, 0xec, 0xd2, 0x99, 0xd6, 0x4d, 0x34, 0xb4, 0x78, 0x99, 0xcb, 0xe3, 0x48,
	0x1c, 0xfd, 0x08, 0x56, 0xc6, 0x2e, 0x83, 0x87, 0xa9, 0x85, 0xdc, 0xa2, 0xe6, 0x0f, 0x2f, 0x73,
	0xd1, 0xa9, 0x72, 0x0d, 0x50, 0x38, 0xde, 0xa3, 0x81, 0x61, 0xd2, 0x98, 0xbe, 0xb2, 0x50, 0x7f,
	0x35, 0x92, 0x9e, 0x9a, 0x88, 0x25, 0x21, 0x7d, 0x3a, 0x09, 0x7f, 0x48, 0xc2, 0x72, 0x94, 0x84,
	0xef, 0x5c, 0xa7, 0xd5, 0xf3, 0xea, 0x54, 0x02, 0x65, 0x94, 0xb5, 0x6b, 0x90, 0x35, 0xbd, 0x11,
	0x03, 0xfa, 0xd4, 0xc2, 0xe2, 0x92, 0x12, 0xe8, 0x06, 0x6b, 0x46, 0xa2, 0xc3, 0xa6, 0x17, 0x1e,
	0x76, 0x2a, 0xc4, 0x8a, 0x91, 0x7a, 0xd4, 0x70, 0x74, 0xf3, 0x60, 0xec, 0x1e, 0x86, 0x22, 0xa1,
	0xb8, 0xc0, 0x69, 0xdb, 0x9c, 0x84, 0x5e, 0x87, 0x65, 0x8b, 0x38, 0xc6, 0x31, 0xb1, 0x22, 0xa1,
	0x2c, 0x17, 0x2a, 0x49, 0xaa, 0x10, 0xd3, 0xfe, 0x96, 0x04, 0x15, 0xcb, 0x96, 0x9d, 0x7c, 0xf7,
	0xe2, 0xac, 0x02, 0x1b, 0xd2, 0x7c, 0x2f, 0x34, 0x9c, 0xa7, 0x1c, 0x74, 0x22, 0x73, 0xfa, 0xa8,
	0xb9, 0x67, 0x39, 0xea, 0x06, 0x14, 0x0c, 0xf3, 0xd0, 0xf5, 0x3e, 0x73, 0x88, 0x35, 0x24, 0x12,
	0xa9, 0xe2, 0x24, 0x74, 0x13, 0x90, 0x45, 0xfc, 0x80, 0xb0, 0x13, 0x58, 0xfa, 0x53, 0xee, 0xca,
	0xea, 0x54, 0x4c, 0x92, 0x16, 0x57, 0x0b, 0xc3, 0x48, 0xf9, 0xa9, 0x5b, 0xc4, 0xa1, 0x86, 0x8c,
	0x71, 0x51, 0x12, 0x1b, 0x8c, 0xa6, 0xfd, 0x23, 0x01, 0xab, 0xb1, 0xe8, 0x3d, 0x47, 0xf4, 0x8b,
	0xc3, 0x55, 0xea, 0x19, 0xe0, 0xea, 0x3b, 0xd7, 0x94, 0x36, 0x80, 0x42, 0xdb, 0x0e, 0x69, 0x54,
	0x03, 0x3f, 0x04, 0x25, 0x94, 0x77, 0x5c, 0x56, 0xc1, 0x22, 0x08, 0x90, 0x95, 0x3f, 0x11, 0xbf,
	0x93, 0x56, 0x92, 0x6a, 0xea, 0x4e, 0x5a, 0x49, 0xa9, 0x69, 0xed, 0xef, 0x49, 0x28, 0x0a, 0xb3,
	0xcf, 0xfd, 0xca, 0x7d, 0x08, 0x8a, 0x4c, 0xbe, 0x18, 0x45, 0x4e, 0xcd, 0x86, 0x71, 0x1f, 0xa2,
	0x41, 0x31, 0x72, 0x3c, 0xd2, 0x2a, 0x7f, 0x99, 0x80, 0xa8, 0x58, 0xd0, 0x75, 0x48, 0xcf, 0x6f,
	0xff, 0x62, 0x23, 0xa0, 0x34, 0xc0, 0x05, 0xd9, 0x9d, 0x64, 0xcd, 0x49, 0x40, 0x1e, 0xd8, 0x61,
	0x34, 0x26, 0xa7, 0x70, 0x61, 0xe4, 0x59, 0x58, 0x92, 0xd0, 0x9b, 0x90, 0x09, 0xbc, 0x31, 0x25,
	0x32, 0x83, 0xb1, 0x1f, 0x14, 0x30, 0x23, 0x4b, 0x73, 0x42, 0xe6, 0x4e, 0x5a, 0x49, 0xab, 0x19,
	0xed, 0xdf, 0x09, 0x28, 0xd6, 0x7c, 0xdf, 0x39, 0x8e, 0xf2, 0xf2, 0x01, 0xe4, 0xcc, 0x03, 0xc3,
	0x1d, 0x92, 0xe8, 0x67, 0x89, 0x2b, 0x53, 0x2b, 0x71, 0xc1, 0xea, 0x36, 0x97, 0x8a, 0x7e, 0x17,
	0x90, 0x3a, 0xe5, 0xdf, 0x25, 0x20, 0x2b, 0x38, 0xa8, 0x0a, 0x2f, 0x90, 0x23, 0x9f, 0x98, 0x54,
	0x3f, 0xe5, 0x37, 0x9f, 0x32, 0xf1, 0xaa, 0x60, 0xdd, 0x8d, 0x79, 0xff, 0x36, 0x64, 0xc7, 0x7e,
	0x48, 0x02, 0x2a, 0xf3, 0x31, 0x3f, 0x26, 0x58, 0x0a, 0xa1, 0x57, 0x21, 0x6b, 0x11, 0x87, 0xc8,
	0xd3, 0xce, 0x5c, 0x45, 0xc9, 0xd2, 0x6c, 0xfe, 0x2e, 0x32, 0xa7, 0x9f, 0x77, 0x79, 0x68, 0xff,
	0x49, 0x82, 0x1a, 0x5d, 0x94, 0xf0, 0xb9, 0x3d, 0xc3, 0xaf, 0xc1, 0x32, 0xef, 0xba, 0xf5, 0x49,
	0xa3, 0x9a, 0x12, 0xb8, 0xc1, 0xa9, 0x77, 0x65, 0xb7, 0xba, 0x01, 0x45, 0xd6, 0x5b, 0x4d, 0x64,
	0x78, 0xa7, 0x82, 0x59, 0xbf, 0x15, 0x49, 0xbc, 0x01, 0x2b, 0x2e, 0x39, 0xa2, 0xba, 0x6f, 0x0c,
	0x89, 0x4e, 0xbd, 0x43, 0xe2, 0x4a, 0x00, 0x2a, 0x31, 0x72, 0xcf, 0x18, 0x92, 0x01, 0x23, 0xa2,
	0x2b, 0x00, 0x5c, 0x44, 0x0c, 0x15, 0x0c, 0x1d, 0x33, 0x38, 0xcf, 0x28, 0x7c, 0xa2, 0x40, 0xb7,
	0xa0, 0x18, 0xda, 0x43, 0xd7, 0xa0, 0xe3, 0x80, 0x0c, 0x06, 0x6d, 0x09, 0xb9, 0x4f, 0x99, 0x46,
	0x95, 0x87, 0x27, 0x95, 0x04, 0x1f, 0x35, 0x4f, 0x29, 0x9e, 0x69, 0x2f, 0x94, 0xd9, 0xf6, 0x42,
	0xfb, 0x6b, 0x12, 0x56, 0x63, 0xf1, 0x7d, 0xee, 0xd7, 0xbd, 0x05, 0xf9, 0x08, 0xed, 0xa2, 0xfb,
	0xfe, 0xfa, 0x59, 0x48, 0x9c, 0x78, 0x52, 0xd5, 0x27, 0x3f, 0x09, 0x09, 0x3b, 0x53, 0xed, 0x79,
	0xc1, 0x4e, 0xcf, 0x09, 0x76, 0xf9, 0x13, 0xc8, 0x4f, 0xac, 0xa0, 0xb7, 0x4e, 0x01, 0xc4, 0x1c,
	0x34, 0x3e, 0x85, 0x0e, 0x57, 0x00, 0x58, 0x3c, 0x89, 0xc5, 0x9b, 0x47, 0x31, 0x86, 0xe6, 0x05,
	0x65, 0x37, 0x70, 0xd8, 0x0c, 0x9a, 0xe1, 0x18, 0x80, 0xde, 0x87, 0xdc, 0x88, 0x8c, 0xf6, 0x18,
	0x6c, 0x8b, 0xfb, 0x7d, 0xde, 0x90, 0x1c, 0x89, 0xb3, 0xb7, 0xcc, 0x0f, 0xec, 0x91, 0x11, 0x1c,
	0x8b, 0x9f, 0xe8, 0x70, 0xb4, 0x44, 0xd7, 0x20, 0x1f, 0x4d, 0xc9, 0xd1, 0xaf, 0x34, 0xa7, 0x87,
	0xe8, 0x29, 0x5b, 0xfb, 0x73, 0x12, 0xb2, 0x22, 0xde, 0xe8, 0x03, 0x80, 0x68, 0x12, 0x7e, 0xe6,
	0x91, 0x3d, 0x2f, 0x35, 0x5a, 0xd6, 0x14, 0xed, 0x92, 0xe7, 0xa3, 0x1d, 0x83, 0x5b, 0x42, 0x4d,
	0x4b, 0x22, 0xe3, 0x85, 0xd9, 0xdc, 0x57, 0x9b, 0xd4, 0xb4, 0xa2, 0x80, 0x32, 0xc1, 0xf2, 0x2f,
	0x20, 0xcd, 0x68, 0x2c, 0xb0, 0xa6, 0x33, 0x66, 0x4f, 0x58, 0xe4, 0x64, 0x1a, 0xe7, 0x25, 0xa5,
	0x65, 0xa1, 0x97, 0x20, 0x2f, 0xe2, 0xc3, 0xb8, 0x49, 0xce, 0x55, 0x04, 0xa1, 0x65, 0xa1, 0x32,
	0x28, 0x13, 0xd8, 0x13, 0xd7, 0x74, 0xb2, 0x66, 0x8a, 0x81, 0xb1, 0x4f, 0x75, 0x4a, 0x02, 0x31,
	0x1d, 0xa7, 0xb1, 0xc2, 0x08, 0x03, 0x12, 0x8c, 0xae, 0x3d, 0x4a, 0x42, 0x56, 0x94, 0x2f, 0xca,
	0x42, 0xb2, 0xfb, 0x91, 0xba, 0x84, 0x2e, 0xc0, 0xea, 0x9d, 0xee, 0x2e, 0xee, 0xd4, 0xda, 0x7a,
	0xa7, 0x3b, 0xd0, 0x77, 0xba, 0xbb, 0x9d, 0x86, 0x9a, 0x40, 0x57, 0xe0, 0x72, 0xa7, 0xab, 0x47,
	0x9c, 0x1e, 0x6e, 0xdd, 0xad, 0xe1, 0xfb, 0x7a, 0x1d, 0x77, 0x3f, 0x6a, 0x62, 0x35, 0x89, 0xd6,
	0xa1, 0xcc, 0xa4, 0x17, 0xf0, 0x53, 0xe8, 0x22, 0xa0, 0x38, 0x5f, 0xd2, 0x33, 0x68, 0x03, 0x5e,
	0x6e, 0x75, 0xfa, 0xbb, 0x3b, 0x3b, 0xad, 0xed, 0x56, 0xb3, 0x33, 0x2b, 0xd0, 0x57, 0xd3, 0xe8,
	0x65, 0x58, 0xeb, 0xee, 0xec, 0xf4, 0x9b, 0x03, 0xee, 0xce, 0xfd, 0xe6, 0x40, 0xaf, 0x7d, 0x5c,
	0x6b, 0xb5, 0x6b, 0xf5, 0x76, 0x53, 0xcd, 0xa2, 0x15, 0x28, 0xdc, 0xc3, 0xdd, 0xce, 0x2d, 0x1d,
	0x77, 0x77, 0x07, 0x4d, 0x35, 0xc7, 0xdc, 0xef, 0xe1, 0x6e, 0xaf, 0xdb, 0xaf, 0xb5, 0xf5, 0xbb,
	0xad, 0xfe, 0xdd, 0xda, 0x60, 0xfb, 0xb6, 0xaa, 0xa0, 0x97, 0xe0, 0x52, 0x73, 0xb0, 0xdd, 0xd0,
	0x07, 0xb8, 0xd6, 0xe9, 0xd7, 0xb6, 0x07, 0xad, 0x6e, 0x47, 0xdf, 0xa9, 0xb5, 0xda, 0xcd, 0x86,
	0x9a, 0x67, 0x46, 0x98, 0xed, 0x5a, 0xbb, 0xdd, 0xbd, 0xd7, 0x6c, 0xa8, 0x80, 0x2e, 0xc1, 0x0b,
	0xc2, 0x6a, 0xad, 0xd7, 0x6b, 0x76, 0x1a, 0xba, 0x70, 0x40, 0x2d, 0x30, 0x67, 0x5a, 0x9d, 0x46,
	0xf3, 0x13, 0xfd, 0x76, 0xad, 0xaf, 0xdf, 0xc2, 0xcd, 0xda, 0xa0, 0x89, 0x23, 0x6e, 0x91, 0xed,
	0x8d, 0x9b, 0xb7, 0x5a, 0x7d, 0x46, 0x9c, 0xec, 0x5d, 0xba, 0xe6, 0x82, 0x3a, 0xfb, 0x5b, 0x02,
	0x2a, 0x40, 0xae, 0xd5, 0xf9, 0xb8, 0xd6, 0x6e, 0x35, 0xd4, 0x25, 0xa4, 0x40, 0xba, 0xd3, 0xed,
	0x34, 0xd5, 0x04, 0xfb, 0xba, 0xf5, 0x69, 0xab, 0xa7, 0x26, 0x51, 0x09, 0xf2, 0x9f, 0xf6, 0x07,
	0xb5, 0x4e, 0xa3, 0x86, 0x1b, 0x6a, 0x0a, 0x01, 0x64, 0xfb, 0x9d, 0x5a, 0xaf, 0x77, 0x5f, 0x4d,
	0xb3, 0x58, 0x33, 0x21, 0xb6, 0x6f, 0xbb, 0x5b, 0x6b, 0xe8, 0x8d, 0xe6, 0x76, 0xf7, 0x6e, 0x0f,
	0x37, 0xfb, 0xfd, 0x56, 0xb7, 0xa3, 0x66, 0xb6, 0xbe, 0x48, 0x4d, 0x5f, 0xff, 0xef, 0x43, 0x9a,
	0x75, 0x0c, 0xe8, 0xc2, 0x6c, 0x07, 0xc1, 0x9f, 0x8d, 0xf2, 0xc5, 0xf9, 0x8d, 0x05, 0x7a, 0x1f,
	0x32, 0xfc, 0x39, 0x43, 0x17, 0xe7, 0x3f, 0xca, 0xe5, 0x4b, 0x67, 0xe8, 0x52, 0xf3, 0x3d, 0x48,
	0xb3, 0x09, 0x3a, 0xbe, 0x61, 0xec, 0xe7, 0x85, 0xf8, 0x86, 0xf1, 0x41, 0xfb, 0x46, 0x02, 0x7d,
	0x00, 0x59, 0x31, 0xd4, 0xa0, 0xd3, 0xb6, 0xa7, 0xb3, 0x66, 0x79, 0xed, 0x2c, 0x43, 0xa8, 0x6f,
	0x26, 0xd0, 0x6d, 0xc8, 0x4f, 0x1a, 0x58, 0x54, 0x8e, 0xef, 0x72, 0x7a, 0x26, 0x28, 0xbf, 0x34,
	0x97, 0x17, 0xd9, 0xb9, 0xc1, 0x2c, 0x95, 0x58, 0x2c, 0x26, 0xc0, 0x1b, 0xb7, 0x36, 0xfb, 0xee,
	0xc6, 0xad, 0x9d, 0x41, 0xea, 0x7a, 0xf3, 0xe1, 0xff, 0xd6, 0x97, 0xfe, 0xf2, 0x68, 0x3d, 0xf1,
	0xf0, 0xd1, 0x7a, 0xe2, 0x9b, 0x47, 0xeb, 0x89, 0xdf, 0x3f, 0x5e, 0x5f, 0xfa, 0xfa, 0xf1, 0x7a,
	0xe2, 0x9b, 0xc7, 0xeb, 0x4b, 0xff, 0x7c, 0xbc, 0xbe, 0xf4, 0xe9, 0xab, 0x43, 0xaf, 0x3a, 0x34,
	0x3e, 0x27, 0x94, 0x92, 0xaa, 0x45, 0x1e, 0x5c, 0x37, 0xbd, 0x80, 0x5c, 0x9f, 0xf9, 0x37, 0x69,
	0x2f, 0xcb, 0xbf, 0xde, 0xfd, 0x7f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x39, 0x98, 0xe0, 0x84, 0x67,
	0x1a, 0x00, 0x00,
}

func (this *Label) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Label)
	if !ok {
		that2, ok := that.(Label)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *LabelSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LabelSet)
	if !ok {
		that2, ok := that.(LabelSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if !this.Labels[i].Equal(&that1.Labels[i]) {
			return false
		}
	}
	return true
}
func (this *LabelSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LabelSelector)
	if !ok {
		that2, ok := that.(LabelSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Include.Equal(&that1.Include) {
		return false
	}
	if !this.Exclude.Equal(&that1.Exclude) {
		return false
	}
	return true
}
func (this *JournalSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JournalSpec)
	if !ok {
		that2, ok := that.(JournalSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Replication != that1.Replication {
		return false
	}
	if !this.LabelSet.Equal(&that1.LabelSet) {
		return false
	}
	if !this.Fragment.Equal(&that1.Fragment) {
		return false
	}
	if this.Flags != that1.Flags {
		return false
	}
	if this.MaxAppendRate != that1.MaxAppendRate {
		return false
	}
	return true
}
func (this *JournalSpec_Fragment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JournalSpec_Fragment)
	if !ok {
		that2, ok := that.(JournalSpec_Fragment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Length != that1.Length {
		return false
	}
	if this.CompressionCodec != that1.CompressionCodec {
		return false
	}
	if len(this.Stores) != len(that1.Stores) {
		return false
	}
	for i := range this.Stores {
		if this.Stores[i] != that1.Stores[i] {
			return false
		}
	}
	if this.RefreshInterval != that1.RefreshInterval {
		return false
	}
	if this.Retention != that1.Retention {
		return false
	}
	if this.FlushInterval != that1.FlushInterval {
		return false
	}
	if this.PathPostfixTemplate != that1.PathPostfixTemplate {
		return false
	}
	return true
}
func (this *ProcessSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProcessSpec)
	if !ok {
		that2, ok := that.(ProcessSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(&that1.Id) {
		return false
	}
	if this.Endpoint != that1.Endpoint {
		return false
	}
	return true
}
func (this *ProcessSpec_ID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProcessSpec_ID)
	if !ok {
		that2, ok := that.(ProcessSpec_ID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Zone != that1.Zone {
		return false
	}
	if this.Suffix != that1.Suffix {
		return false
	}
	return true
}
func (this *BrokerSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BrokerSpec)
	if !ok {
		that2, ok := that.(BrokerSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ProcessSpec.Equal(&that1.ProcessSpec) {
		return false
	}
	if this.JournalLimit != that1.JournalLimit {
		return false
	}
	return true
}
func (this *Fragment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Fragment)
	if !ok {
		that2, ok := that.(Fragment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Journal != that1.Journal {
		return false
	}
	if this.Begin != that1.Begin {
		return false
	}
	if this.End != that1.End {
		return false
	}
	if !this.Sum.Equal(&that1.Sum) {
		return false
	}
	if this.CompressionCodec != that1.CompressionCodec {
		return false
	}
	if this.BackingStore != that1.BackingStore {
		return false
	}
	if this.ModTime != that1.ModTime {
		return false
	}
	if this.PathPostfix != that1.PathPostfix {
		return false
	}
	return true
}
func (this *SHA1Sum) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SHA1Sum)
	if !ok {
		that2, ok := that.(SHA1Sum)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Part1 != that1.Part1 {
		return false
	}
	if this.Part2 != that1.Part2 {
		return false
	}
	if this.Part3 != that1.Part3 {
		return false
	}
	return true
}
func (this *ReadRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadRequest)
	if !ok {
		that2, ok := that.(ReadRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Header.Equal(that1.Header) {
		return false
	}
	if this.Journal != that1.Journal {
		return false
	}
	if this.Offset != that1.Offset {
		return false
	}
	if this.Block != that1.Block {
		return false
	}
	if this.DoNotProxy != that1.DoNotProxy {
		return false
	}
	if this.MetadataOnly != that1.MetadataOnly {
		return false
	}
	if this.EndOffset != that1.EndOffset {
		return false
	}
	return true
}
func (this *ReadResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadResponse)
	if !ok {
		that2, ok := that.(ReadResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if !this.Header.Equal(that1.Header) {
		return false
	}
	if this.Offset != that1.Offset {
		return false
	}
	if this.WriteHead != that1.WriteHead {
		return false
	}
	if !this.Fragment.Equal(that1.Fragment) {
		return false
	}
	if this.FragmentUrl != that1.FragmentUrl {
		return false
	}
	if !bytes.Equal(this.Content, that1.Content) {
		return false
	}
	return true
}
func (this *AppendRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AppendRequest)
	if !ok {
		that2, ok := that.(AppendRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Header.Equal(that1.Header) {
		return false
	}
	if this.Journal != that1.Journal {
		return false
	}
	if this.DoNotProxy != that1.DoNotProxy {
		return false
	}
	if this.Offset != that1.Offset {
		return false
	}
	if !this.CheckRegisters.Equal(that1.CheckRegisters) {
		return false
	}
	if !this.UnionRegisters.Equal(that1.UnionRegisters) {
		return false
	}
	if !this.SubtractRegisters.Equal(that1.SubtractRegisters) {
		return false
	}
	if !bytes.Equal(this.Content, that1.Content) {
		return false
	}
	return true
}
func (this *AppendResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AppendResponse)
	if !ok {
		that2, ok := that.(AppendResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if !this.Header.Equal(&that1.Header) {
		return false
	}
	if !this.Commit.Equal(that1.Commit) {
		return false
	}
	if !this.Registers.Equal(that1.Registers) {
		return false
	}
	if this.TotalChunks != that1.TotalChunks {
		return false
	}
	if this.DelayedChunks != that1.DelayedChunks {
		return false
	}
	return true
}
func (this *ReplicateRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplicateRequest)
	if !ok {
		that2, ok := that.(ReplicateRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Header.Equal(that1.Header) {
		return false
	}
	if !this.Proposal.Equal(that1.Proposal) {
		return false
	}
	if !this.Registers.Equal(that1.Registers) {
		return false
	}
	if this.Acknowledge != that1.Acknowledge {
		return false
	}
	if this.DeprecatedJournal != that1.DeprecatedJournal {
		return false
	}
	if !bytes.Equal(this.Content, that1.Content) {
		return false
	}
	if this.ContentDelta != that1.ContentDelta {
		return false
	}
	return true
}
func (this *ReplicateResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplicateResponse)
	if !ok {
		that2, ok := that.(ReplicateResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if !this.Header.Equal(that1.Header) {
		return false
	}
	if !this.Fragment.Equal(that1.Fragment) {
		return false
	}
	if !this.Registers.Equal(that1.Registers) {
		return false
	}
	return true
}
func (this *ListRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListRequest)
	if !ok {
		that2, ok := that.(ListRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Selector.Equal(&that1.Selector) {
		return false
	}
	return true
}
func (this *ListResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListResponse)
	if !ok {
		that2, ok := that.(ListResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if !this.Header.Equal(&that1.Header) {
		return false
	}
	if len(this.Journals) != len(that1.Journals) {
		return false
	}
	for i := range this.Journals {
		if !this.Journals[i].Equal(&that1.Journals[i]) {
			return false
		}
	}
	return true
}
func (this *ListResponse_Journal) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListResponse_Journal)
	if !ok {
		that2, ok := that.(ListResponse_Journal)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Spec.Equal(&that1.Spec) {
		return false
	}
	if this.ModRevision != that1.ModRevision {
		return false
	}
	if !this.Route.Equal(&that1.Route) {
		return false
	}
	return true
}
func (this *ApplyRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ApplyRequest)
	if !ok {
		that2, ok := that.(ApplyRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Changes) != len(that1.Changes) {
		return false
	}
	for i := range this.Changes {
		if !this.Changes[i].Equal(&that1.Changes[i]) {
			return false
		}
	}
	return true
}
func (this *ApplyRequest_Change) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ApplyRequest_Change)
	if !ok {
		that2, ok := that.(ApplyRequest_Change)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExpectModRevision != that1.ExpectModRevision {
		return false
	}
	if !this.Upsert.Equal(that1.Upsert) {
		return false
	}
	if this.Delete != that1.Delete {
		return false
	}
	return true
}
func (this *ApplyResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ApplyResponse)
	if !ok {
		that2, ok := that.(ApplyResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if !this.Header.Equal(&that1.Header) {
		return false
	}
	return true
}
func (this *FragmentsRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FragmentsRequest)
	if !ok {
		that2, ok := that.(FragmentsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Header.Equal(that1.Header) {
		return false
	}
	if this.Journal != that1.Journal {
		return false
	}
	if this.BeginModTime != that1.BeginModTime {
		return false
	}
	if this.EndModTime != that1.EndModTime {
		return false
	}
	if this.NextPageToken != that1.NextPageToken {
		return false
	}
	if this.PageLimit != that1.PageLimit {
		return false
	}
	if this.SignatureTTL != nil && that1.SignatureTTL != nil {
		if *this.SignatureTTL != *that1.SignatureTTL {
			return false
		}
	} else if this.SignatureTTL != nil {
		return false
	} else if that1.SignatureTTL != nil {
		return false
	}
	if this.DoNotProxy != that1.DoNotProxy {
		return false
	}
	return true
}
func (this *FragmentsResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FragmentsResponse)
	if !ok {
		that2, ok := that.(FragmentsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if !this.Header.Equal(&that1.Header) {
		return false
	}
	if len(this.Fragments) != len(that1.Fragments) {
		return false
	}
	for i := range this.Fragments {
		if !this.Fragments[i].Equal(&that1.Fragments[i]) {
			return false
		}
	}
	if this.NextPageToken != that1.NextPageToken {
		return false
	}
	return true
}
func (this *FragmentsResponse__Fragment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FragmentsResponse__Fragment)
	if !ok {
		that2, ok := that.(FragmentsResponse__Fragment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Spec.Equal(&that1.Spec) {
		return false
	}
	if this.SignedUrl != that1.SignedUrl {
		return false
	}
	return true
}
func (this *Route) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Route)
	if !ok {
		that2, ok := that.(Route)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Members) != len(that1.Members) {
		return false
	}
	for i := range this.Members {
		if !this.Members[i].Equal(&that1.Members[i]) {
			return false
		}
	}
	if this.Primary != that1.Primary {
		return false
	}
	if len(this.Endpoints) != len(that1.Endpoints) {
		return false
	}
	for i := range this.Endpoints {
		if this.Endpoints[i] != that1.Endpoints[i] {
			return false
		}
	}
	return true
}
func (this *Header) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Header)
	if !ok {
		that2, ok := that.(Header)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ProcessId.Equal(&that1.ProcessId) {
		return false
	}
	if !this.Route.Equal(&that1.Route) {
		return false
	}
	if !this.Etcd.Equal(&that1.Etcd) {
		return false
	}
	return true
}
func (this *Header_Etcd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Header_Etcd)
	if !ok {
		that2, ok := that.(Header_Etcd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClusterId != that1.ClusterId {
		return false
	}
	if this.MemberId != that1.MemberId {
		return false
	}
	if this.Revision != that1.Revision {
		return false
	}
	if this.RaftTerm != that1.RaftTerm {
		return false
	}
	return true
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// JournalClient is the client API for Journal service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type JournalClient interface {
	// List Journals, their JournalSpecs and current Routes.
	List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error)
	// Apply changes to the collection of Journals managed by the brokers.
	Apply(ctx context.Context, in *ApplyRequest, opts ...grpc.CallOption) (*ApplyResponse, error)
	// Read from a specific Journal.
	Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (Journal_ReadClient, error)
	// Append content to a specific Journal.
	Append(ctx context.Context, opts ...grpc.CallOption) (Journal_AppendClient, error)
	// Replicate appended content of a Journal. Replicate is used between broker
	// peers in the course of processing Append transactions, but is not intended
	// for direct use by clients.
	Replicate(ctx context.Context, opts ...grpc.CallOption) (Journal_ReplicateClient, error)
	// List Fragments of a Journal.
	ListFragments(ctx context.Context, in *FragmentsRequest, opts ...grpc.CallOption) (*FragmentsResponse, error)
}

type journalClient struct {
	cc *grpc.ClientConn
}

func NewJournalClient(cc *grpc.ClientConn) JournalClient {
	return &journalClient{cc}
}

func (c *journalClient) List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error) {
	out := new(ListResponse)
	err := c.cc.Invoke(ctx, "/protocol.Journal/List", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *journalClient) Apply(ctx context.Context, in *ApplyRequest, opts ...grpc.CallOption) (*ApplyResponse, error) {
	out := new(ApplyResponse)
	err := c.cc.Invoke(ctx, "/protocol.Journal/Apply", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *journalClient) Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (Journal_ReadClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Journal_serviceDesc.Streams[0], "/protocol.Journal/Read", opts...)
	if err != nil {
		return nil, err
	}
	x := &journalReadClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Journal_ReadClient interface {
	Recv() (*ReadResponse, error)
	grpc.ClientStream
}

type journalReadClient struct {
	grpc.ClientStream
}

func (x *journalReadClient) Recv() (*ReadResponse, error) {
	m := new(ReadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *journalClient) Append(ctx context.Context, opts ...grpc.CallOption) (Journal_AppendClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Journal_serviceDesc.Streams[1], "/protocol.Journal/Append", opts...)
	if err != nil {
		return nil, err
	}
	x := &journalAppendClient{stream}
	return x, nil
}

type Journal_AppendClient interface {
	Send(*AppendRequest) error
	CloseAndRecv() (*AppendResponse, error)
	grpc.ClientStream
}

type journalAppendClient struct {
	grpc.ClientStream
}

func (x *journalAppendClient) Send(m *AppendRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *journalAppendClient) CloseAndRecv() (*AppendResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(AppendResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *journalClient) Replicate(ctx context.Context, opts ...grpc.CallOption) (Journal_ReplicateClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Journal_serviceDesc.Streams[2], "/protocol.Journal/Replicate", opts...)
	if err != nil {
		return nil, err
	}
	x := &journalReplicateClient{stream}
	return x, nil
}

type Journal_ReplicateClient interface {
	Send(*ReplicateRequest) error
	Recv() (*ReplicateResponse, error)
	grpc.ClientStream
}

type journalReplicateClient struct {
	grpc.ClientStream
}

func (x *journalReplicateClient) Send(m *ReplicateRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *journalReplicateClient) Recv() (*ReplicateResponse, error) {
	m := new(ReplicateResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *journalClient) ListFragments(ctx context.Context, in *FragmentsRequest, opts ...grpc.CallOption) (*FragmentsResponse, error) {
	out := new(FragmentsResponse)
	err := c.cc.Invoke(ctx, "/protocol.Journal/ListFragments", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// JournalServer is the server API for Journal service.
type JournalServer interface {
	// List Journals, their JournalSpecs and current Routes.
	List(context.Context, *ListRequest) (*ListResponse, error)
	// Apply changes to the collection of Journals managed by the brokers.
	Apply(context.Context, *ApplyRequest) (*ApplyResponse, error)
	// Read from a specific Journal.
	Read(*ReadRequest, Journal_ReadServer) error
	// Append content to a specific Journal.
	Append(Journal_AppendServer) error
	// Replicate appended content of a Journal. Replicate is used between broker
	// peers in the course of processing Append transactions, but is not intended
	// for direct use by clients.
	Replicate(Journal_ReplicateServer) error
	// List Fragments of a Journal.
	ListFragments(context.Context, *FragmentsRequest) (*FragmentsResponse, error)
}

// UnimplementedJournalServer can be embedded to have forward compatible implementations.
type UnimplementedJournalServer struct {
}

func (*UnimplementedJournalServer) List(ctx context.Context, req *ListRequest) (*ListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (*UnimplementedJournalServer) Apply(ctx context.Context, req *ApplyRequest) (*ApplyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Apply not implemented")
}
func (*UnimplementedJournalServer) Read(req *ReadRequest, srv Journal_ReadServer) error {
	return status.Errorf(codes.Unimplemented, "method Read not implemented")
}
func (*UnimplementedJournalServer) Append(srv Journal_AppendServer) error {
	return status.Errorf(codes.Unimplemented, "method Append not implemented")
}
func (*UnimplementedJournalServer) Replicate(srv Journal_ReplicateServer) error {
	return status.Errorf(codes.Unimplemented, "method Replicate not implemented")
}
func (*UnimplementedJournalServer) ListFragments(ctx context.Context, req *FragmentsRequest) (*FragmentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListFragments not implemented")
}

func RegisterJournalServer(s *grpc.Server, srv JournalServer) {
	s.RegisterService(&_Journal_serviceDesc, srv)
}

func _Journal_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JournalServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.Journal/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JournalServer).List(ctx, req.(*ListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Journal_Apply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JournalServer).Apply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.Journal/Apply",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JournalServer).Apply(ctx, req.(*ApplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Journal_Read_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(JournalServer).Read(m, &journalReadServer{stream})
}

type Journal_ReadServer interface {
	Send(*ReadResponse) error
	grpc.ServerStream
}

type journalReadServer struct {
	grpc.ServerStream
}

func (x *journalReadServer) Send(m *ReadResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Journal_Append_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(JournalServer).Append(&journalAppendServer{stream})
}

type Journal_AppendServer interface {
	SendAndClose(*AppendResponse) error
	Recv() (*AppendRequest, error)
	grpc.ServerStream
}

type journalAppendServer struct {
	grpc.ServerStream
}

func (x *journalAppendServer) SendAndClose(m *AppendResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *journalAppendServer) Recv() (*AppendRequest, error) {
	m := new(AppendRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Journal_Replicate_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(JournalServer).Replicate(&journalReplicateServer{stream})
}

type Journal_ReplicateServer interface {
	Send(*ReplicateResponse) error
	Recv() (*ReplicateRequest, error)
	grpc.ServerStream
}

type journalReplicateServer struct {
	grpc.ServerStream
}

func (x *journalReplicateServer) Send(m *ReplicateResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *journalReplicateServer) Recv() (*ReplicateRequest, error) {
	m := new(ReplicateRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Journal_ListFragments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FragmentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JournalServer).ListFragments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.Journal/ListFragments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JournalServer).ListFragments(ctx, req.(*FragmentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Journal_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protocol.Journal",
	HandlerType: (*JournalServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _Journal_List_Handler,
		},
		{
			MethodName: "Apply",
			Handler:    _Journal_Apply_Handler,
		},
		{
			MethodName: "ListFragments",
			Handler:    _Journal_ListFragments_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Read",
			Handler:       _Journal_Read_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Append",
			Handler:       _Journal_Append_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Replicate",
			Handler:       _Journal_Replicate_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "broker/protocol/protocol.proto",
}

func (m *Label) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Label) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Label) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LabelSet) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabelSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LabelSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for iNdEx := len(m.Labels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Labels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocol(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LabelSelector) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabelSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LabelSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Exclude.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProtocol(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Include.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProtocol(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *JournalSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JournalSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JournalSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxAppendRate != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.MaxAppendRate))
		i--
		dAtA[i] = 0x38
	}
	if m.Flags != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.Flags))
		i--
		dAtA[i] = 0x30
	}
	{
		size, err := m.Fragment.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProtocol(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.LabelSet.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProtocol(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Replication != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.Replication))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JournalSpec_Fragment) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JournalSpec_Fragment) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JournalSpec_Fragment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PathPostfixTemplate) > 0 {
		i -= len(m.PathPostfixTemplate)
		copy(dAtA[i:], m.PathPostfixTemplate)
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.PathPostfixTemplate)))
		i--
		dAtA[i] = 0x3a
	}
	n5, err5 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.FlushInterval, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.FlushInterval):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintProtocol(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x32
	n6, err6 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.Retention, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.Retention):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintProtocol(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x2a
	n7, err7 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.RefreshInterval, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.RefreshInterval):])
	if err7 != nil {
		return 0, err7
	}
	i -= n7
	i = encodeVarintProtocol(dAtA, i, uint64(n7))
	i--
	dAtA[i] = 0x22
	if len(m.Stores) > 0 {
		for iNdEx := len(m.Stores) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Stores[iNdEx])
			copy(dAtA[i:], m.Stores[iNdEx])
			i = encodeVarintProtocol(dAtA, i, uint64(len(m.Stores[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.CompressionCodec != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.CompressionCodec))
		i--
		dAtA[i] = 0x10
	}
	if m.Length != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProcessSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProcessSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Endpoint) > 0 {
		i -= len(m.Endpoint)
		copy(dAtA[i:], m.Endpoint)
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.Endpoint)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProtocol(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ProcessSpec_ID) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessSpec_ID) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProcessSpec_ID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Suffix) > 0 {
		i -= len(m.Suffix)
		copy(dAtA[i:], m.Suffix)
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.Suffix)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Zone) > 0 {
		i -= len(m.Zone)
		copy(dAtA[i:], m.Zone)
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.Zone)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BrokerSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BrokerSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BrokerSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.JournalLimit != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.JournalLimit))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.ProcessSpec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProtocol(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Fragment) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Fragment) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Fragment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PathPostfix) > 0 {
		i -= len(m.PathPostfix)
		copy(dAtA[i:], m.PathPostfix)
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.PathPostfix)))
		i--
		dAtA[i] = 0x42
	}
	if m.ModTime != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.ModTime))
		i--
		dAtA[i] = 0x38
	}
	if len(m.BackingStore) > 0 {
		i -= len(m.BackingStore)
		copy(dAtA[i:], m.BackingStore)
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.BackingStore)))
		i--
		dAtA[i] = 0x32
	}
	if m.CompressionCodec != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.CompressionCodec))
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.Sum.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProtocol(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.End != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x18
	}
	if m.Begin != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.Begin))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Journal) > 0 {
		i -= len(m.Journal)
		copy(dAtA[i:], m.Journal)
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.Journal)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SHA1Sum) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SHA1Sum) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SHA1Sum) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Part3 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.Part3))
		i--
		dAtA[i] = 0x1d
	}
	if m.Part2 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Part2))
		i--
		dAtA[i] = 0x11
	}
	if m.Part1 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Part1))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *ReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EndOffset != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.EndOffset))
		i--
		dAtA[i] = 0x38
	}
	if m.MetadataOnly {
		i--
		if m.MetadataOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.DoNotProxy {
		i--
		if m.DoNotProxy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Block {
		i--
		if m.Block {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Offset != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Journal) > 0 {
		i -= len(m.Journal)
		copy(dAtA[i:], m.Journal)
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.Journal)))
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReadResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.FragmentUrl) > 0 {
		i -= len(m.FragmentUrl)
		copy(dAtA[i:], m.FragmentUrl)
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.FragmentUrl)))
		i--
		dAtA[i] = 0x32
	}
	if m.Fragment != nil {
		{
			size, err := m.Fragment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.WriteHead != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.WriteHead))
		i--
		dAtA[i] = 0x20
	}
	if m.Offset != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x18
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppendRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SubtractRegisters != nil {
		{
			size, err := m.SubtractRegisters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.UnionRegisters != nil {
		{
			size, err := m.UnionRegisters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.CheckRegisters != nil {
		{
			size, err := m.CheckRegisters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Offset != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x22
	}
	if m.DoNotProxy {
		i--
		if m.DoNotProxy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Journal) > 0 {
		i -= len(m.Journal)
		copy(dAtA[i:], m.Journal)
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.Journal)))
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppendResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DelayedChunks != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.DelayedChunks))
		i--
		dAtA[i] = 0x30
	}
	if m.TotalChunks != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.TotalChunks))
		i--
		dAtA[i] = 0x28
	}
	if m.Registers != nil {
		{
			size, err := m.Registers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProtocol(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Status != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReplicateRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplicateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Registers != nil {
		{
			size, err := m.Registers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Acknowledge {
		i--
		if m.Acknowledge {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.ContentDelta != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.ContentDelta))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x22
	}
	if m.Proposal != nil {
		{
			size, err := m.Proposal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DeprecatedJournal) > 0 {
		i -= len(m.DeprecatedJournal)
		copy(dAtA[i:], m.DeprecatedJournal)
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.DeprecatedJournal)))
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplicateResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplicateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Registers != nil {
		{
			size, err := m.Registers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Fragment != nil {
		{
			size, err := m.Fragment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Selector.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProtocol(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ListResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Journals) > 0 {
		for iNdEx := len(m.Journals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Journals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocol(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProtocol(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Status != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListResponse_Journal) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListResponse_Journal) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListResponse_Journal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Route.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProtocol(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.ModRevision != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.ModRevision))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProtocol(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ApplyRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Changes) > 0 {
		for iNdEx := len(m.Changes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Changes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocol(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ApplyRequest_Change) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyRequest_Change) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyRequest_Change) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Delete) > 0 {
		i -= len(m.Delete)
		copy(dAtA[i:], m.Delete)
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.Delete)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Upsert != nil {
		{
			size, err := m.Upsert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ExpectModRevision != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.ExpectModRevision))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ApplyResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProtocol(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Status != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FragmentsRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FragmentsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FragmentsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DoNotProxy {
		i--
		if m.DoNotProxy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.SignatureTTL != nil {
		n33, err33 := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.SignatureTTL, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(*m.SignatureTTL):])
		if err33 != nil {
			return 0, err33
		}
		i -= n33
		i = encodeVarintProtocol(dAtA, i, uint64(n33))
		i--
		dAtA[i] = 0x3a
	}
	if m.PageLimit != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.PageLimit))
		i--
		dAtA[i] = 0x30
	}
	if m.NextPageToken != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.NextPageToken))
		i--
		dAtA[i] = 0x28
	}
	if m.EndModTime != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.EndModTime))
		i--
		dAtA[i] = 0x20
	}
	if m.BeginModTime != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.BeginModTime))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Journal) > 0 {
		i -= len(m.Journal)
		copy(dAtA[i:], m.Journal)
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.Journal)))
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FragmentsResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FragmentsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FragmentsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NextPageToken != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.NextPageToken))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Fragments) > 0 {
		for iNdEx := len(m.Fragments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fragments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocol(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProtocol(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Status != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FragmentsResponse__Fragment) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FragmentsResponse__Fragment) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FragmentsResponse__Fragment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SignedUrl) > 0 {
		i -= len(m.SignedUrl)
		copy(dAtA[i:], m.SignedUrl)
		i = encodeVarintProtocol(dAtA, i, uint64(len(m.SignedUrl)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProtocol(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Route) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Route) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Route) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Endpoints) > 0 {
		for iNdEx := len(m.Endpoints) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Endpoints[iNdEx])
			copy(dAtA[i:], m.Endpoints[iNdEx])
			i = encodeVarintProtocol(dAtA, i, uint64(len(m.Endpoints[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Primary != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.Primary))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Members[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocol(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Header) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Etcd.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProtocol(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Route.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProtocol(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ProcessId.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProtocol(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Header_Etcd) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Header_Etcd) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header_Etcd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RaftTerm != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.RaftTerm))
		i--
		dAtA[i] = 0x20
	}
	if m.Revision != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.Revision))
		i--
		dAtA[i] = 0x18
	}
	if m.MemberId != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.MemberId))
		i--
		dAtA[i] = 0x10
	}
	if m.ClusterId != 0 {
		i = encodeVarintProtocol(dAtA, i, uint64(m.ClusterId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintProtocol(dAtA []byte, offset int, v uint64) int {
	offset -= sovProtocol(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Label) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	return n
}

func (m *LabelSet) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.ProtoSize()
			n += 1 + l + sovProtocol(uint64(l))
		}
	}
	return n
}

func (m *LabelSelector) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Include.ProtoSize()
	n += 1 + l + sovProtocol(uint64(l))
	l = m.Exclude.ProtoSize()
	n += 1 + l + sovProtocol(uint64(l))
	return n
}

func (m *JournalSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	if m.Replication != 0 {
		n += 1 + sovProtocol(uint64(m.Replication))
	}
	l = m.LabelSet.ProtoSize()
	n += 1 + l + sovProtocol(uint64(l))
	l = m.Fragment.ProtoSize()
	n += 1 + l + sovProtocol(uint64(l))
	if m.Flags != 0 {
		n += 1 + sovProtocol(uint64(m.Flags))
	}
	if m.MaxAppendRate != 0 {
		n += 1 + sovProtocol(uint64(m.MaxAppendRate))
	}
	return n
}

func (m *JournalSpec_Fragment) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Length != 0 {
		n += 1 + sovProtocol(uint64(m.Length))
	}
	if m.CompressionCodec != 0 {
		n += 1 + sovProtocol(uint64(m.CompressionCodec))
	}
	if len(m.Stores) > 0 {
		for _, s := range m.Stores {
			l = len(s)
			n += 1 + l + sovProtocol(uint64(l))
		}
	}
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.RefreshInterval)
	n += 1 + l + sovProtocol(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.Retention)
	n += 1 + l + sovProtocol(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.FlushInterval)
	n += 1 + l + sovProtocol(uint64(l))
	l = len(m.PathPostfixTemplate)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	return n
}

func (m *ProcessSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Id.ProtoSize()
	n += 1 + l + sovProtocol(uint64(l))
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	return n
}

func (m *ProcessSpec_ID) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Zone)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	l = len(m.Suffix)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	return n
}

func (m *BrokerSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ProcessSpec.ProtoSize()
	n += 1 + l + sovProtocol(uint64(l))
	if m.JournalLimit != 0 {
		n += 1 + sovProtocol(uint64(m.JournalLimit))
	}
	return n
}

func (m *Fragment) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Journal)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	if m.Begin != 0 {
		n += 1 + sovProtocol(uint64(m.Begin))
	}
	if m.End != 0 {
		n += 1 + sovProtocol(uint64(m.End))
	}
	l = m.Sum.ProtoSize()
	n += 1 + l + sovProtocol(uint64(l))
	if m.CompressionCodec != 0 {
		n += 1 + sovProtocol(uint64(m.CompressionCodec))
	}
	l = len(m.BackingStore)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	if m.ModTime != 0 {
		n += 1 + sovProtocol(uint64(m.ModTime))
	}
	l = len(m.PathPostfix)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	return n
}

func (m *SHA1Sum) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Part1 != 0 {
		n += 9
	}
	if m.Part2 != 0 {
		n += 9
	}
	if m.Part3 != 0 {
		n += 5
	}
	return n
}

func (m *ReadRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.ProtoSize()
		n += 1 + l + sovProtocol(uint64(l))
	}
	l = len(m.Journal)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	if m.Offset != 0 {
		n += 1 + sovProtocol(uint64(m.Offset))
	}
	if m.Block {
		n += 2
	}
	if m.DoNotProxy {
		n += 2
	}
	if m.MetadataOnly {
		n += 2
	}
	if m.EndOffset != 0 {
		n += 1 + sovProtocol(uint64(m.EndOffset))
	}
	return n
}

func (m *ReadResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovProtocol(uint64(m.Status))
	}
	if m.Header != nil {
		l = m.Header.ProtoSize()
		n += 1 + l + sovProtocol(uint64(l))
	}
	if m.Offset != 0 {
		n += 1 + sovProtocol(uint64(m.Offset))
	}
	if m.WriteHead != 0 {
		n += 1 + sovProtocol(uint64(m.WriteHead))
	}
	if m.Fragment != nil {
		l = m.Fragment.ProtoSize()
		n += 1 + l + sovProtocol(uint64(l))
	}
	l = len(m.FragmentUrl)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	return n
}

func (m *AppendRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.ProtoSize()
		n += 1 + l + sovProtocol(uint64(l))
	}
	l = len(m.Journal)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	if m.DoNotProxy {
		n += 2
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	if m.Offset != 0 {
		n += 1 + sovProtocol(uint64(m.Offset))
	}
	if m.CheckRegisters != nil {
		l = m.CheckRegisters.ProtoSize()
		n += 1 + l + sovProtocol(uint64(l))
	}
	if m.UnionRegisters != nil {
		l = m.UnionRegisters.ProtoSize()
		n += 1 + l + sovProtocol(uint64(l))
	}
	if m.SubtractRegisters != nil {
		l = m.SubtractRegisters.ProtoSize()
		n += 1 + l + sovProtocol(uint64(l))
	}
	return n
}

func (m *AppendResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovProtocol(uint64(m.Status))
	}
	l = m.Header.ProtoSize()
	n += 1 + l + sovProtocol(uint64(l))
	if m.Commit != nil {
		l = m.Commit.ProtoSize()
		n += 1 + l + sovProtocol(uint64(l))
	}
	if m.Registers != nil {
		l = m.Registers.ProtoSize()
		n += 1 + l + sovProtocol(uint64(l))
	}
	if m.TotalChunks != 0 {
		n += 1 + sovProtocol(uint64(m.TotalChunks))
	}
	if m.DelayedChunks != 0 {
		n += 1 + sovProtocol(uint64(m.DelayedChunks))
	}
	return n
}

func (m *ReplicateRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.ProtoSize()
		n += 1 + l + sovProtocol(uint64(l))
	}
	l = len(m.DeprecatedJournal)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	if m.Proposal != nil {
		l = m.Proposal.ProtoSize()
		n += 1 + l + sovProtocol(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	if m.ContentDelta != 0 {
		n += 1 + sovProtocol(uint64(m.ContentDelta))
	}
	if m.Acknowledge {
		n += 2
	}
	if m.Registers != nil {
		l = m.Registers.ProtoSize()
		n += 1 + l + sovProtocol(uint64(l))
	}
	return n
}

func (m *ReplicateResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovProtocol(uint64(m.Status))
	}
	if m.Header != nil {
		l = m.Header.ProtoSize()
		n += 1 + l + sovProtocol(uint64(l))
	}
	if m.Fragment != nil {
		l = m.Fragment.ProtoSize()
		n += 1 + l + sovProtocol(uint64(l))
	}
	if m.Registers != nil {
		l = m.Registers.ProtoSize()
		n += 1 + l + sovProtocol(uint64(l))
	}
	return n
}

func (m *ListRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Selector.ProtoSize()
	n += 1 + l + sovProtocol(uint64(l))
	return n
}

func (m *ListResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovProtocol(uint64(m.Status))
	}
	l = m.Header.ProtoSize()
	n += 1 + l + sovProtocol(uint64(l))
	if len(m.Journals) > 0 {
		for _, e := range m.Journals {
			l = e.ProtoSize()
			n += 1 + l + sovProtocol(uint64(l))
		}
	}
	return n
}

func (m *ListResponse_Journal) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Spec.ProtoSize()
	n += 1 + l + sovProtocol(uint64(l))
	if m.ModRevision != 0 {
		n += 1 + sovProtocol(uint64(m.ModRevision))
	}
	l = m.Route.ProtoSize()
	n += 1 + l + sovProtocol(uint64(l))
	return n
}

func (m *ApplyRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Changes) > 0 {
		for _, e := range m.Changes {
			l = e.ProtoSize()
			n += 1 + l + sovProtocol(uint64(l))
		}
	}
	return n
}

func (m *ApplyRequest_Change) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExpectModRevision != 0 {
		n += 1 + sovProtocol(uint64(m.ExpectModRevision))
	}
	if m.Upsert != nil {
		l = m.Upsert.ProtoSize()
		n += 1 + l + sovProtocol(uint64(l))
	}
	l = len(m.Delete)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	return n
}

func (m *ApplyResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovProtocol(uint64(m.Status))
	}
	l = m.Header.ProtoSize()
	n += 1 + l + sovProtocol(uint64(l))
	return n
}

func (m *FragmentsRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.ProtoSize()
		n += 1 + l + sovProtocol(uint64(l))
	}
	l = len(m.Journal)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	if m.BeginModTime != 0 {
		n += 1 + sovProtocol(uint64(m.BeginModTime))
	}
	if m.EndModTime != 0 {
		n += 1 + sovProtocol(uint64(m.EndModTime))
	}
	if m.NextPageToken != 0 {
		n += 1 + sovProtocol(uint64(m.NextPageToken))
	}
	if m.PageLimit != 0 {
		n += 1 + sovProtocol(uint64(m.PageLimit))
	}
	if m.SignatureTTL != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.SignatureTTL)
		n += 1 + l + sovProtocol(uint64(l))
	}
	if m.DoNotProxy {
		n += 2
	}
	return n
}

func (m *FragmentsResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovProtocol(uint64(m.Status))
	}
	l = m.Header.ProtoSize()
	n += 1 + l + sovProtocol(uint64(l))
	if len(m.Fragments) > 0 {
		for _, e := range m.Fragments {
			l = e.ProtoSize()
			n += 1 + l + sovProtocol(uint64(l))
		}
	}
	if m.NextPageToken != 0 {
		n += 1 + sovProtocol(uint64(m.NextPageToken))
	}
	return n
}

func (m *FragmentsResponse__Fragment) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Spec.ProtoSize()
	n += 1 + l + sovProtocol(uint64(l))
	l = len(m.SignedUrl)
	if l > 0 {
		n += 1 + l + sovProtocol(uint64(l))
	}
	return n
}

func (m *Route) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.ProtoSize()
			n += 1 + l + sovProtocol(uint64(l))
		}
	}
	if m.Primary != 0 {
		n += 1 + sovProtocol(uint64(m.Primary))
	}
	if len(m.Endpoints) > 0 {
		for _, s := range m.Endpoints {
			l = len(s)
			n += 1 + l + sovProtocol(uint64(l))
		}
	}
	return n
}

func (m *Header) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ProcessId.ProtoSize()
	n += 1 + l + sovProtocol(uint64(l))
	l = m.Route.ProtoSize()
	n += 1 + l + sovProtocol(uint64(l))
	l = m.Etcd.ProtoSize()
	n += 1 + l + sovProtocol(uint64(l))
	return n
}

func (m *Header_Etcd) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterId != 0 {
		n += 1 + sovProtocol(uint64(m.ClusterId))
	}
	if m.MemberId != 0 {
		n += 1 + sovProtocol(uint64(m.MemberId))
	}
	if m.Revision != 0 {
		n += 1 + sovProtocol(uint64(m.Revision))
	}
	if m.RaftTerm != 0 {
		n += 1 + sovProtocol(uint64(m.RaftTerm))
	}
	return n
}

func sovProtocol(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProtocol(x uint64) (n int) {
	return sovProtocol(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Label) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Label: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Label: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabelSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabelSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabelSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, Label{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabelSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabelSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabelSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Include", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Include.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exclude", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Exclude.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JournalSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JournalSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JournalSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = Journal(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replication", wireType)
			}
			m.Replication = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Replication |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LabelSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fragment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Fragment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= JournalSpec_Flag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAppendRate", wireType)
			}
			m.MaxAppendRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAppendRate |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JournalSpec_Fragment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fragment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fragment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionCodec", wireType)
			}
			m.CompressionCodec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompressionCodec |= CompressionCodec(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stores", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stores = append(m.Stores, FragmentStore(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.RefreshInterval, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retention", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.Retention, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlushInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.FlushInterval, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathPostfixTemplate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathPostfixTemplate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = Endpoint(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessSpec_ID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suffix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Suffix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BrokerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BrokerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BrokerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProcessSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JournalLimit", wireType)
			}
			m.JournalLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JournalLimit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Fragment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fragment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fragment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Journal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Journal = Journal(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			m.Begin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Begin |= Offset(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= Offset(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Sum.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionCodec", wireType)
			}
			m.CompressionCodec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompressionCodec |= CompressionCodec(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackingStore", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackingStore = FragmentStore(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModTime", wireType)
			}
			m.ModTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathPostfix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathPostfix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SHA1Sum) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SHA1Sum: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SHA1Sum: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Part1", wireType)
			}
			m.Part1 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Part1 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Part2", wireType)
			}
			m.Part2 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Part2 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Part3", wireType)
			}
			m.Part3 = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.Part3 = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Journal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Journal = Journal(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= Offset(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Block = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoNotProxy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DoNotProxy = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MetadataOnly = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndOffset", wireType)
			}
			m.EndOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndOffset |= Offset(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= Offset(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteHead", wireType)
			}
			m.WriteHead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteHead |= Offset(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fragment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fragment == nil {
				m.Fragment = &Fragment{}
			}
			if err := m.Fragment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragmentUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FragmentUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Journal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Journal = Journal(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoNotProxy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DoNotProxy = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= Offset(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckRegisters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CheckRegisters == nil {
				m.CheckRegisters = &LabelSelector{}
			}
			if err := m.CheckRegisters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnionRegisters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnionRegisters == nil {
				m.UnionRegisters = &LabelSet{}
			}
			if err := m.UnionRegisters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubtractRegisters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubtractRegisters == nil {
				m.SubtractRegisters = &LabelSet{}
			}
			if err := m.SubtractRegisters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Fragment{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Registers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Registers == nil {
				m.Registers = &LabelSet{}
			}
			if err := m.Registers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalChunks", wireType)
			}
			m.TotalChunks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalChunks |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayedChunks", wireType)
			}
			m.DelayedChunks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelayedChunks |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedJournal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeprecatedJournal = Journal(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proposal == nil {
				m.Proposal = &Fragment{}
			}
			if err := m.Proposal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentDelta", wireType)
			}
			m.ContentDelta = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContentDelta |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acknowledge", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Acknowledge = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Registers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Registers == nil {
				m.Registers = &LabelSet{}
			}
			if err := m.Registers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fragment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fragment == nil {
				m.Fragment = &Fragment{}
			}
			if err := m.Fragment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Registers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Registers == nil {
				m.Registers = &LabelSet{}
			}
			if err := m.Registers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Selector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Journals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Journals = append(m.Journals, ListResponse_Journal{})
			if err := m.Journals[len(m.Journals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListResponse_Journal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Journal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Journal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModRevision", wireType)
			}
			m.ModRevision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModRevision |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Route.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Changes = append(m.Changes, ApplyRequest_Change{})
			if err := m.Changes[len(m.Changes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyRequest_Change) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Change: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Change: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectModRevision", wireType)
			}
			m.ExpectModRevision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpectModRevision |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upsert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Upsert == nil {
				m.Upsert = &JournalSpec{}
			}
			if err := m.Upsert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delete = Journal(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FragmentsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FragmentsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FragmentsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Journal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Journal = Journal(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginModTime", wireType)
			}
			m.BeginModTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeginModTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndModTime", wireType)
			}
			m.EndModTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndModTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			m.NextPageToken = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextPageToken |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageLimit", wireType)
			}
			m.PageLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignatureTTL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignatureTTL == nil {
				m.SignatureTTL = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.SignatureTTL, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoNotProxy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DoNotProxy = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FragmentsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FragmentsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FragmentsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fragments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fragments = append(m.Fragments, FragmentsResponse__Fragment{})
			if err := m.Fragments[len(m.Fragments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			m.NextPageToken = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextPageToken |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FragmentsResponse__Fragment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: _Fragment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: _Fragment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignedUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Route) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Route: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Route: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, ProcessSpec_ID{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Primary", wireType)
			}
			m.Primary = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Primary |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoints", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoints = append(m.Endpoints, Endpoint(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProcessId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Route.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Etcd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Etcd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Header_Etcd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Etcd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Etcd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			m.ClusterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberId", wireType)
			}
			m.MemberId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			m.Revision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Revision |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftTerm", wireType)
			}
			m.RaftTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftTerm |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProtocol(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProtocol
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtocol
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProtocol
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupProtocol
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthProtocol
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthProtocol        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProtocol          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupProtocol = fmt.Errorf("proto: unexpected end of group")
)
