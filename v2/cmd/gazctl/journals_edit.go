package main

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"

	"github.com/LiveRamp/gazette/v2/pkg/client"
	mbp "github.com/LiveRamp/gazette/v2/pkg/mainboilerplate"
	"github.com/LiveRamp/gazette/v2/pkg/protocol"
	"github.com/LiveRamp/gazette/v2/pkg/protocol/journalspace"
	log "github.com/sirupsen/logrus"
	"gopkg.in/yaml.v2"
)

var whitespace = regexp.MustCompile(`^\s*$`)

type cmdJournalsEdit struct {
	Selector string `long:"selector" short:"l" required:"true" description:"Label Selector query to filter on" no-ini:"true"`
}

func (cmd *cmdJournalsEdit) Execute([]string) error {
	startup()

	var (
		isRetry  bool
		retryMsg string

		// userEdits contains the last version of the edits made by the user.
		// Any comments generated by the edit-retry loop are not included.
		userEdits []byte

		// preservedEdits contains the name of the last temp file used by the
		// editor. This file is preserved when the user cancels an edit attempt
		// that has failed validation at least once. If a user cancels without
		// attempting any changes, it is considered a no-op and nothing is
		// preserved.
		preservedEdits *string
	)

	// Notify users of preserved edits if they exist.
	defer func() {
		if preservedEdits == nil {
			return
		}
		if _, err := os.Stat(*preservedEdits); err == nil {
			_, _ = fmt.Fprintf(os.Stderr, "Last edits saved to %s.\n", *preservedEdits)
		}
	}()

	for {
		var buf = &bytes.Buffer{}
		var preEdit []byte
		var headerLines = 0

		headerLines += writeHeader(buf)

		if isRetry {
			if retryMsg != "" {
				headerLines += writeRetryMessage(buf, retryMsg)
			}
			writePostHeader(buf, headerLines)
			buf.Write(userEdits)
			preEdit = userEdits
		} else {
			writePostHeader(buf, headerLines)
			if _, err := io.Copy(buf, cmd.selectSpecs()); err != nil {
				return err
			}
			preEdit = pruneHeader(buf.Bytes())
		}

		var edited, currPath, err = openTempFile("gazctl-edit-", buf)
		if err != nil {
			return err
		}

		// Now that a newer temp file is written to disk, it is safe to remove
		// the previous one.
		if preservedEdits != nil {
			log.WithField("file", *preservedEdits).Debug("remove temp file")
			_ = os.Remove(*preservedEdits)
		}
		preservedEdits = &currPath

		userEdits = pruneHeader(edited)
		if isEmptyEdit(userEdits) {
			log.WithField("file", currPath).Debug("remove temp file")
			_ = os.Remove(currPath)
			_, _ = fmt.Fprintln(os.Stderr, "Cancelled, empty file.")
			return nil
		}

		// When a user does not make any edit, it is interpreted as a
		// cancellation of the edit attempt.
		if bytes.Equal(preEdit, userEdits) {
			if isRetry {
				// When at least one edit attempt was made, a cancellation is
				// considered an error because the last change was not applied;
				// it could not have been because it was invalid.
				return errors.New("Cancelled, no changes to invalid file.")
			} else {
				// When no edit attempt is made, a cancellation is not
				// considered an error because the current (live) specs are
				// consistent with definitions last seen in the editor.
				log.WithField("file", currPath).Debug("remove temp file")
				_ = os.Remove(currPath)
				_, _ = fmt.Fprintln(os.Stderr, "Cancelled, nothing to do.")
				return nil
			}
		}

		// Attempt to apply edits.
		if err := applyHoistedJournalSpecYAML(userEdits); err != nil {
			isRetry = true
			retryMsg = err.Error()
			continue
		}

		_ = os.Remove(currPath)
		return nil
	}
}

// selectSpecs returns the hoisted YAML specs of journals matching the selector.
func (cmd *cmdJournalsEdit) selectSpecs() io.Reader {
	var err error
	var req protocol.ListRequest
	var ctx = context.Background()

	req.Selector, err = protocol.ParseLabelSelector(cmd.Selector)
	mbp.Must(err, "failed to parse label selector", "selector", cmd.Selector)

	resp, err := client.ListAll(ctx, protocol.NewJournalClient(journalsCfg.Broker.Dial(ctx)), req)
	mbp.Must(err, "failed to list journals")

	var buf = &bytes.Buffer{}
	if len(resp.Journals) == 0 {
		log.WithField("selector", cmd.Selector).Panic("no journals match selector")
	}
	writeHoistedJournalSpecTree(buf, resp)

	return buf
}

func openTempFile(prefix string, r io.Reader) ([]byte, string, error) {
	var tmpFile, errTemp = ioutil.TempFile("", prefix)
	if errTemp != nil {
		return nil, "", errTemp
	}
	var path = tmpFile.Name()
	defer func() {
		_ = tmpFile.Close()
	}()

	if _, err := io.Copy(tmpFile, r); err != nil {
		_ = os.Remove(path)
		return nil, "", err
	}
	log.WithField("file", path).Debug("write temp file")

	// Must close the file before the editor can open it.
	_ = tmpFile.Close()
	if err := editFile(path); err != nil {
		return nil, path, err
	}

	var b, errRead = ioutil.ReadFile(path)
	return b, path, errRead
}

func editFile(path string) error {
	var absPath, err = filepath.Abs(path)
	if err != nil {
		return err
	}

	// TODO: Allow editor to be set through env var; default to vi.
	cmd := exec.Command("/bin/sh", "-c", editor()+" "+absPath)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.Stdin = os.Stdin
	err = cmd.Run()
	if err != nil {
		return err
	}
	return nil
}

func editor() string {
	var vs = []string{"GAZ_EDITOR", "EDITOR"}
	for _, v := range vs {
		if e := os.Getenv(v); e != "" {
			return e
		}
	}

	return "vi"
}

// isEmptyEdit returns true iff b contains only whitespace.
func isEmptyEdit(b []byte) bool {
	return whitespace.Match(b)
}

func applyHoistedJournalSpecYAML(b []byte) error {
	var tree journalspace.Node
	if err := yaml.UnmarshalStrict(b, &tree); err != nil {
		return err
	}
	if err := tree.Validate(); err != nil {
		return err
	}

	var req = newJournalSpecApplyRequest(&tree)
	if err := req.Validate(); err != nil {
		return err
	}

	var ctx = context.Background()
	if resp, err := client.ApplyJournals(ctx, journalsCfg.Broker.JournalClient(ctx), req); err != nil {
		return err
	} else {
		log.WithField("rev", resp.Header.Etcd.Revision).Info("successfully applied")
	}

	return nil
}

func writeHeader(w io.Writer) int {
	_, _ = fmt.Fprint(w, `#⚙ Edit the spec below. Lines beginning with a '#⚙' or '#⚠' are generated by
#⚙ this tool and will be ignored as input. An empty file will abort the edit.
#⚙ If there is an error validating and applying this file, it will be reopened.
#⚙
`)
	return 4
}

func writeRetryMessage(w io.Writer, msg string) int {
	// Highlight error message with U+26A0 aka ⚠ aka "warning sign".
	_, _ = fmt.Fprintln(w, "#\u26a0 There were errors validating or applying the spec. No changes were applied.\n#\u26a0")
	var lines = bytes.Split([]byte(msg), []byte("\n"))
	for _, line := range lines {
		_, _ = fmt.Fprintf(w, "#\u26a0 %s\n", line)
	}
	_, _ = fmt.Fprintln(w, "#\u26a0")
	return len(lines) + 3
}

func writePostHeader(w io.Writer, n int) {
	_, _ = fmt.Fprintf(w, "#⚙ Note: Any line numbers above do not include this header (%d lines).\n#⚙\n", n+2)
}

func pruneHeader(b []byte) []byte {
	var pruned []byte
	var lines = bytes.Split(b, []byte("\n"))
	var lastLine = len(lines) - 1
	for i, line := range lines {
		if bytes.HasPrefix(line, []byte("#⚙")) || bytes.HasPrefix(line, []byte("#\u26a0")) {
			continue
		}
		pruned = append(pruned, line...)
		if i < lastLine {
			pruned = append(pruned, '\n')
		}
	}
	return pruned
}
