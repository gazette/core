// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: consumer.proto

package consumer

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import protocol "github.com/LiveRamp/gazette/v2/pkg/protocol"
import recoverylog "github.com/LiveRamp/gazette/v2/pkg/recoverylog"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/golang/protobuf/ptypes/duration"

import time "time"
import github_com_LiveRamp_gazette_v2_pkg_protocol "github.com/LiveRamp/gazette/v2/pkg/protocol"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Status is a response status code, used across Gazette Consumer RPC APIs.
type Status int32

const (
	Status_OK Status = 0
	// The named shard does not exist.
	Status_SHARD_NOT_FOUND Status = 1
	// There is no current primary consumer process for the shard. This is a
	// temporary condition which should quickly resolve, assuming sufficient
	// consumer capacity.
	Status_NO_SHARD_PRIMARY Status = 2
	// The present consumer process is not the assigned primary for the shard,
	// and was not instructed to proxy the request.
	Status_NOT_SHARD_PRIMARY Status = 3
	// The Etcd transaction failed. Returned by Update RPC when an
	// expect_mod_revision of the UpdateRequest differs from the current
	// ModRevision of the ShardSpec within the store.
	Status_ETCD_TRANSACTION_FAILED Status = 4
)

var Status_name = map[int32]string{
	0: "OK",
	1: "SHARD_NOT_FOUND",
	2: "NO_SHARD_PRIMARY",
	3: "NOT_SHARD_PRIMARY",
	4: "ETCD_TRANSACTION_FAILED",
}
var Status_value = map[string]int32{
	"OK":                      0,
	"SHARD_NOT_FOUND":         1,
	"NO_SHARD_PRIMARY":        2,
	"NOT_SHARD_PRIMARY":       3,
	"ETCD_TRANSACTION_FAILED": 4,
}

func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}
func (Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_consumer_9e9608ed376e3e47, []int{0}
}

type ReplicaStatus_Code int32

const (
	ReplicaStatus_IDLE ReplicaStatus_Code = 0
	// The replica is actively playing the historical log.
	ReplicaStatus_BACKFILL ReplicaStatus_Code = 100
	// The replica has finished playing the historical log, and is tailing the
	// live log to locally mirror recorded operations as they are produced. It
	// is a "hot standby" and can take over as primary at any time.
	ReplicaStatus_TAILING ReplicaStatus_Code = 200
	// The replica is actively serving as primary.
	ReplicaStatus_PRIMARY ReplicaStatus_Code = 300
	// The replica has encountered an unrecoverable error.
	ReplicaStatus_FAILED ReplicaStatus_Code = 400
)

var ReplicaStatus_Code_name = map[int32]string{
	0:   "IDLE",
	100: "BACKFILL",
	200: "TAILING",
	300: "PRIMARY",
	400: "FAILED",
}
var ReplicaStatus_Code_value = map[string]int32{
	"IDLE":     0,
	"BACKFILL": 100,
	"TAILING":  200,
	"PRIMARY":  300,
	"FAILED":   400,
}

func (x ReplicaStatus_Code) String() string {
	return proto.EnumName(ReplicaStatus_Code_name, int32(x))
}
func (ReplicaStatus_Code) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_consumer_9e9608ed376e3e47, []int{2, 0}
}

// ShardSpec describes a shard and its configuration. Shards represent the
// combination of a consumer application, a specific journal selected for
// consumption, and a recoverylog journal which replicates the stateful
// consumption of that journal by the consumer. ShardSpec serves as a
// allocator ItemValue.
type ShardSpec struct {
	// ID of the Shard.
	Id ShardID `protobuf:"bytes,1,opt,name=id,proto3,casttype=ShardID" json:"id,omitempty" yaml:",omitempty"`
	// Sources of the shard, uniquely ordered on Source journal.
	Sources []ShardSpec_Source `protobuf:"bytes,2,rep,name=sources" json:"sources" yaml:",omitempty"`
	// Prefix of the Journal into which the Shard's `recoverylog` will be recorded.
	// The complete Journal name is built as "{recovery_log_prefix}/{shard_id}".
	RecoveryLogPrefix string `protobuf:"bytes,3,opt,name=recovery_log_prefix,json=recoveryLogPrefix,proto3" json:"recovery_log_prefix,omitempty" yaml:"recovery_log_prefix,omitempty"`
	// Prefix of Etcd keys into which `recoverylog` FSMHints are written to and
	// read from. FSMHints allow readers of the `recoverylog` to efficiently
	// determine the minimum fragments of log which must be read to fully recover
	// local store state. The complete hint key written by the Shard primary is:
	//
	//   "{hint_prefix}/{shard_id}.primary"
	//
	// The primary will regularly produce updated hints into this key, and
	// players of the log will similarly utilize hints from this key.
	HintPrefix string `protobuf:"bytes,4,opt,name=hint_prefix,json=hintPrefix,proto3" json:"hint_prefix,omitempty" yaml:"hint_prefix,omitempty"`
	// Backups of verified `recoverylog` FSMHints, retained as a disaster-recovery
	// mechanism. On completing playback, a player will write recovered hints to:
	//
	//   "{hints_prefix}/{shard_id}.backup.0".
	//
	// It also move hints previously stored under
	// "{hints_prefix/{shard_id}.backup.0" to
	// "{hints_prefix/{shard_id}.backup.1", and so on, keeping at most
	// |hint_backups| distinct sets of FSMHints.
	//
	// In the case of disaster or data-loss, these copied hints can be an important
	// fallback for recovering a consistent albeit older version of the Shard
	// store, with each relying on only progressively older portions of the
	// recoverylog.
	//
	// When pruning the recoverylog, log fragments which are older than (and no
	// longer required by) the *oldest* backup are discarded, ensuring that
	// all hints remain valid for playback.
	HintBackups int32 `protobuf:"varint,5,opt,name=hint_backups,json=hintBackups,proto3" json:"hint_backups,omitempty" yaml:"hint_backups,omitempty"`
	// Max duration of shard transactions. This duration upper-bounds the amount
	// of time during which a transaction may process messages before it must flush
	// and commit. It may run for less time if an input message stall occurs (eg,
	// no decoded journal message is ready without blocking). A typical value
	// would be `1s`: applications which perform extensive aggregation over message
	// streams exhibiting locality of "hot" keys may benefit from larger values.
	MaxTxnDuration time.Duration `protobuf:"bytes,6,opt,name=max_txn_duration,json=maxTxnDuration,stdduration" json:"max_txn_duration" yaml:"max_txn_duration,omitempty"`
	// Min duration of shard transactions. This duration lower-bounds the amount
	// of time during which a transaction must process messages before it may flush
	// and commit. It may run for more time if additional messages are available
	// (eg, decoded journal messages are ready without blocking). Note also that
	// transactions are pipelined: a current transaction may process messages while
	// a prior transaction's recoverylog writes flush to Gazette, but it cannot
	// begin to commit until the prior transaction writes complete. In other words
	// even if |min_txn_quantum| is zero, some degree of message batching is
	// expected due to the network delay inherent in Gazette writes. A typical
	// value of would be `0s`: applications which perform extensive aggregation
	// may benefit from larger values.
	MinTxnDuration time.Duration `protobuf:"bytes,7,opt,name=min_txn_duration,json=minTxnDuration,stdduration" json:"min_txn_duration" yaml:"min_txn_duration,omitempty"`
	// Disable processing of the Shard.
	Disable bool `protobuf:"varint,8,opt,name=disable,proto3" json:"disable,omitempty" yaml:",omitempty"`
	// Hot standbys is the desired number of consumer processes which should be
	// replicating the primary consumer's recovery log. Standbys are allocated in
	// a separate availability zone of the current primary, and tail the live log
	// to continuously mirror the primary's on-disk DB file structure. Should the
	// primary experience failure, one of the hot standbys will be assigned to take
	// over as the new shard primary, which is accomplished by simply opening its
	// local copy of the RocksDB.
	//
	// Note that under regular operation, Shard hand-off is zero downtime even if
	// standbys are zero, as the current primary will not cede ownership until the
	// replacement process has completed log playback. However, a process failure
	// will leave the Shard without an owner until log playback can complete.
	HotStandbys uint32 `protobuf:"varint,9,opt,name=hot_standbys,json=hotStandbys,proto3" json:"hot_standbys,omitempty" yaml:"hot_standbys,omitempty"`
	// User-defined Labels of this ShardSpec. The label "id" is reserved and may
	// not be used with a ShardSpec's labels.
	protocol.LabelSet `protobuf:"bytes,10,opt,name=labels,embedded=labels" json:"labels" yaml:",omitempty,inline"`
}

func (m *ShardSpec) Reset()         { *m = ShardSpec{} }
func (m *ShardSpec) String() string { return proto.CompactTextString(m) }
func (*ShardSpec) ProtoMessage()    {}
func (*ShardSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_consumer_9e9608ed376e3e47, []int{0}
}
func (m *ShardSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ShardSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardSpec.Merge(dst, src)
}
func (m *ShardSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ShardSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ShardSpec proto.InternalMessageInfo

// Sources define the set of Journals which this Shard consumes.
// At least one Source must be specified, and in many use cases only one will
// be needed. For advanced use cases which can benefit, multiple sources may
// be specified to represent a "join" over messages of distinct journals. Note
// the effective mapping of messages to each of the joined journals should
// align (eg, joining a journal of customer updates with one of orders, where
// both are mapped on customer ID). Another powerful pattern is to join each
// partition of a high-volume event stream with a low-volume journal of
// queries, obtaining a reliable distributed scatter/gather query engine.
type ShardSpec_Source struct {
	// Journal which this Shard is consuming.
	Journal github_com_LiveRamp_gazette_v2_pkg_protocol.Journal `protobuf:"bytes,1,opt,name=journal,proto3,casttype=github.com/LiveRamp/gazette/v2/pkg/protocol.Journal" json:"journal,omitempty"`
	// Minimum journal byte offset the shard should begin reading from. Typically
	// this should be zero, as read offsets are persisted to and recovered from
	// the shard store as the journal is processed. |min_offset| can be useful
	// for shard initialization, directing it to skip over undesired historical
	// sections of the journal.
	MinOffset int64 `protobuf:"varint,3,opt,name=min_offset,json=minOffset,proto3" json:"min_offset,omitempty" yaml:"min_offset,omitempty"`
}

func (m *ShardSpec_Source) Reset()         { *m = ShardSpec_Source{} }
func (m *ShardSpec_Source) String() string { return proto.CompactTextString(m) }
func (*ShardSpec_Source) ProtoMessage()    {}
func (*ShardSpec_Source) Descriptor() ([]byte, []int) {
	return fileDescriptor_consumer_9e9608ed376e3e47, []int{0, 0}
}
func (m *ShardSpec_Source) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardSpec_Source) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardSpec_Source.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ShardSpec_Source) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardSpec_Source.Merge(dst, src)
}
func (m *ShardSpec_Source) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ShardSpec_Source) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardSpec_Source.DiscardUnknown(m)
}

var xxx_messageInfo_ShardSpec_Source proto.InternalMessageInfo

// ConsumerSpec describes a Consumer process instance and its configuration.
// It serves as a allocator MemberValue.
type ConsumerSpec struct {
	// ProcessSpec of the consumer.
	protocol.ProcessSpec `protobuf:"bytes,1,opt,name=process_spec,json=processSpec,embedded=process_spec" json:"process_spec" yaml:",inline"`
	// Maximum number of assigned Shards.
	ShardLimit uint32 `protobuf:"varint,2,opt,name=shard_limit,json=shardLimit,proto3" json:"shard_limit,omitempty"`
}

func (m *ConsumerSpec) Reset()         { *m = ConsumerSpec{} }
func (m *ConsumerSpec) String() string { return proto.CompactTextString(m) }
func (*ConsumerSpec) ProtoMessage()    {}
func (*ConsumerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_consumer_9e9608ed376e3e47, []int{1}
}
func (m *ConsumerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsumerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsumerSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ConsumerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsumerSpec.Merge(dst, src)
}
func (m *ConsumerSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ConsumerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsumerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ConsumerSpec proto.InternalMessageInfo

// ReplicaStatus is the status of a ShardSpec assigned to a ConsumerSpec.
// It serves as an allocator AssignmentValue. ReplicaStatus is reduced by taking
// the maximum enum value among statuses. Eg, if a primary is PRIMARY, one
// replica is BACKFILL and the other TAILING, then the status is PRIMARY. If one
// of the replicas transitioned to FAILED, than the status is FAILED. This
// reduction behavior is used to summarize status across all replicas.
type ReplicaStatus struct {
	Code ReplicaStatus_Code `protobuf:"varint,1,opt,name=code,proto3,enum=consumer.ReplicaStatus_Code" json:"code,omitempty"`
	// Errors encountered during replica processing. Set iff |code| is FAILED.
	Errors []string `protobuf:"bytes,2,rep,name=errors" json:"errors,omitempty"`
}

func (m *ReplicaStatus) Reset()         { *m = ReplicaStatus{} }
func (m *ReplicaStatus) String() string { return proto.CompactTextString(m) }
func (*ReplicaStatus) ProtoMessage()    {}
func (*ReplicaStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_consumer_9e9608ed376e3e47, []int{2}
}
func (m *ReplicaStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicaStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplicaStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ReplicaStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicaStatus.Merge(dst, src)
}
func (m *ReplicaStatus) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ReplicaStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicaStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicaStatus proto.InternalMessageInfo

type ListRequest struct {
	// Selector optionally refines the set of shards which will be enumerated.
	// If zero-valued, all shards are returned. Otherwise, only ShardSpecs
	// matching the LabelSelector will be returned. One meta-label "id" is
	// additionally supported by the selector, where "id=example-shard-ID"
	// will match a ShardSpec with ID "example-shard-ID".
	Selector protocol.LabelSelector `protobuf:"bytes,1,opt,name=selector" json:"selector"`
}

func (m *ListRequest) Reset()         { *m = ListRequest{} }
func (m *ListRequest) String() string { return proto.CompactTextString(m) }
func (*ListRequest) ProtoMessage()    {}
func (*ListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_consumer_9e9608ed376e3e47, []int{3}
}
func (m *ListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRequest.Merge(dst, src)
}
func (m *ListRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListRequest proto.InternalMessageInfo

type ListResponse struct {
	// Status of the List RPC.
	Status Status `protobuf:"varint,1,opt,name=status,proto3,enum=consumer.Status" json:"status,omitempty"`
	// Header of the response.
	Header protocol.Header      `protobuf:"bytes,2,opt,name=header" json:"header"`
	Shards []ListResponse_Shard `protobuf:"bytes,3,rep,name=shards" json:"shards"`
}

func (m *ListResponse) Reset()         { *m = ListResponse{} }
func (m *ListResponse) String() string { return proto.CompactTextString(m) }
func (*ListResponse) ProtoMessage()    {}
func (*ListResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_consumer_9e9608ed376e3e47, []int{4}
}
func (m *ListResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListResponse.Merge(dst, src)
}
func (m *ListResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ListResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListResponse proto.InternalMessageInfo

// Shards of the response.
type ListResponse_Shard struct {
	Spec ShardSpec `protobuf:"bytes,1,opt,name=spec" json:"spec"`
	// Current ModRevision of the ShardSpec.
	ModRevision int64 `protobuf:"varint,2,opt,name=mod_revision,json=modRevision,proto3" json:"mod_revision,omitempty"`
	// Route of the shard, including endpoints.
	Route protocol.Route `protobuf:"bytes,3,opt,name=route" json:"route"`
	// Status of each replica. Cardinality and ordering matches |route|.
	Status []ReplicaStatus `protobuf:"bytes,4,rep,name=status" json:"status"`
}

func (m *ListResponse_Shard) Reset()         { *m = ListResponse_Shard{} }
func (m *ListResponse_Shard) String() string { return proto.CompactTextString(m) }
func (*ListResponse_Shard) ProtoMessage()    {}
func (*ListResponse_Shard) Descriptor() ([]byte, []int) {
	return fileDescriptor_consumer_9e9608ed376e3e47, []int{4, 0}
}
func (m *ListResponse_Shard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListResponse_Shard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListResponse_Shard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListResponse_Shard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListResponse_Shard.Merge(dst, src)
}
func (m *ListResponse_Shard) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ListResponse_Shard) XXX_DiscardUnknown() {
	xxx_messageInfo_ListResponse_Shard.DiscardUnknown(m)
}

var xxx_messageInfo_ListResponse_Shard proto.InternalMessageInfo

type ApplyRequest struct {
	Changes []ApplyRequest_Change `protobuf:"bytes,1,rep,name=changes" json:"changes"`
}

func (m *ApplyRequest) Reset()         { *m = ApplyRequest{} }
func (m *ApplyRequest) String() string { return proto.CompactTextString(m) }
func (*ApplyRequest) ProtoMessage()    {}
func (*ApplyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_consumer_9e9608ed376e3e47, []int{5}
}
func (m *ApplyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ApplyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyRequest.Merge(dst, src)
}
func (m *ApplyRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ApplyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyRequest proto.InternalMessageInfo

// Change defines an insertion, update, or deletion to be applied to the set
// of ShardSpecs. Exactly one of |upsert| or |delete| must be set.
type ApplyRequest_Change struct {
	// Expected ModRevision of the current ShardSpec. If the shard is being
	// created, expect_mod_revision is zero.
	ExpectModRevision int64 `protobuf:"varint,1,opt,name=expect_mod_revision,json=expectModRevision,proto3" json:"expect_mod_revision,omitempty"`
	// ShardSpec to be updated (if expect_mod_revision > 0) or created
	// (if expect_mod_revision == 0).
	Upsert *ShardSpec `protobuf:"bytes,2,opt,name=upsert" json:"upsert,omitempty"`
	// Shard to be deleted. expect_mod_revision must not be zero.
	Delete ShardID `protobuf:"bytes,3,opt,name=delete,proto3,casttype=ShardID" json:"delete,omitempty"`
}

func (m *ApplyRequest_Change) Reset()         { *m = ApplyRequest_Change{} }
func (m *ApplyRequest_Change) String() string { return proto.CompactTextString(m) }
func (*ApplyRequest_Change) ProtoMessage()    {}
func (*ApplyRequest_Change) Descriptor() ([]byte, []int) {
	return fileDescriptor_consumer_9e9608ed376e3e47, []int{5, 0}
}
func (m *ApplyRequest_Change) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyRequest_Change) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyRequest_Change.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ApplyRequest_Change) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyRequest_Change.Merge(dst, src)
}
func (m *ApplyRequest_Change) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ApplyRequest_Change) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyRequest_Change.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyRequest_Change proto.InternalMessageInfo

type ApplyResponse struct {
	// Status of the Apply RPC.
	Status Status `protobuf:"varint,1,opt,name=status,proto3,enum=consumer.Status" json:"status,omitempty"`
	// Header of the response.
	Header protocol.Header `protobuf:"bytes,2,opt,name=header" json:"header"`
}

func (m *ApplyResponse) Reset()         { *m = ApplyResponse{} }
func (m *ApplyResponse) String() string { return proto.CompactTextString(m) }
func (*ApplyResponse) ProtoMessage()    {}
func (*ApplyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_consumer_9e9608ed376e3e47, []int{6}
}
func (m *ApplyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ApplyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyResponse.Merge(dst, src)
}
func (m *ApplyResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ApplyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyResponse proto.InternalMessageInfo

type StatRequest struct {
	// Header may be attached by a proxying consumer peer.
	Header *protocol.Header `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	// Shard to Stat.
	Shard ShardID `protobuf:"bytes,2,opt,name=shard,proto3,casttype=ShardID" json:"shard,omitempty"`
}

func (m *StatRequest) Reset()         { *m = StatRequest{} }
func (m *StatRequest) String() string { return proto.CompactTextString(m) }
func (*StatRequest) ProtoMessage()    {}
func (*StatRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_consumer_9e9608ed376e3e47, []int{7}
}
func (m *StatRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *StatRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatRequest.Merge(dst, src)
}
func (m *StatRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *StatRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StatRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StatRequest proto.InternalMessageInfo

type StatResponse struct {
	// Status of the Stat RPC.
	Status Status `protobuf:"varint,1,opt,name=status,proto3,enum=consumer.Status" json:"status,omitempty"`
	// Header of the response.
	Header protocol.Header `protobuf:"bytes,2,opt,name=header" json:"header"`
	// Offsets of journals being read by the shard.
	Offsets map[github_com_LiveRamp_gazette_v2_pkg_protocol.Journal]int64 `protobuf:"bytes,3,rep,name=offsets,castkey=github.com/LiveRamp/gazette/v2/pkg/protocol.Journal" json:"offsets,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *StatResponse) Reset()         { *m = StatResponse{} }
func (m *StatResponse) String() string { return proto.CompactTextString(m) }
func (*StatResponse) ProtoMessage()    {}
func (*StatResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_consumer_9e9608ed376e3e47, []int{8}
}
func (m *StatResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *StatResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatResponse.Merge(dst, src)
}
func (m *StatResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *StatResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StatResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StatResponse proto.InternalMessageInfo

type GetHintsRequest struct {
	// Shard to fetch hints for.
	Shard ShardID `protobuf:"bytes,1,opt,name=shard,proto3,casttype=ShardID" json:"shard,omitempty"`
}

func (m *GetHintsRequest) Reset()         { *m = GetHintsRequest{} }
func (m *GetHintsRequest) String() string { return proto.CompactTextString(m) }
func (*GetHintsRequest) ProtoMessage()    {}
func (*GetHintsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_consumer_9e9608ed376e3e47, []int{9}
}
func (m *GetHintsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetHintsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetHintsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetHintsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetHintsRequest.Merge(dst, src)
}
func (m *GetHintsRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *GetHintsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetHintsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetHintsRequest proto.InternalMessageInfo

type GetHintsResponse struct {
	// Status of the Hints RPC.
	Status Status `protobuf:"varint,1,opt,name=status,proto3,enum=consumer.Status" json:"status,omitempty"`
	// Header of the response.
	Header protocol.Header `protobuf:"bytes,2,opt,name=header" json:"header"`
	// Primary hints for the shard.
	PrimaryHints GetHintsResponse_ResponseHints `protobuf:"bytes,3,opt,name=primary_hints,json=primaryHints" json:"primary_hints"`
	// List of backup hints for a shard. The most recent recovery log hints will be
	// first, any subsequent hints are for historical backup. If there is no value
	// for a hint key the value corresponding hints will be nil.
	BackupHints []GetHintsResponse_ResponseHints `protobuf:"bytes,4,rep,name=backup_hints,json=backupHints" json:"backup_hints"`
}

func (m *GetHintsResponse) Reset()         { *m = GetHintsResponse{} }
func (m *GetHintsResponse) String() string { return proto.CompactTextString(m) }
func (*GetHintsResponse) ProtoMessage()    {}
func (*GetHintsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_consumer_9e9608ed376e3e47, []int{10}
}
func (m *GetHintsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetHintsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetHintsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetHintsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetHintsResponse.Merge(dst, src)
}
func (m *GetHintsResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *GetHintsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetHintsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetHintsResponse proto.InternalMessageInfo

type GetHintsResponse_ResponseHints struct {
	// If the hints value does not exist Hints will be nill.
	Hints *recoverylog.FSMHints `protobuf:"bytes,1,opt,name=hints" json:"hints,omitempty"`
}

func (m *GetHintsResponse_ResponseHints) Reset()         { *m = GetHintsResponse_ResponseHints{} }
func (m *GetHintsResponse_ResponseHints) String() string { return proto.CompactTextString(m) }
func (*GetHintsResponse_ResponseHints) ProtoMessage()    {}
func (*GetHintsResponse_ResponseHints) Descriptor() ([]byte, []int) {
	return fileDescriptor_consumer_9e9608ed376e3e47, []int{10, 0}
}
func (m *GetHintsResponse_ResponseHints) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetHintsResponse_ResponseHints) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetHintsResponse_ResponseHints.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetHintsResponse_ResponseHints) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetHintsResponse_ResponseHints.Merge(dst, src)
}
func (m *GetHintsResponse_ResponseHints) XXX_Size() int {
	return m.ProtoSize()
}
func (m *GetHintsResponse_ResponseHints) XXX_DiscardUnknown() {
	xxx_messageInfo_GetHintsResponse_ResponseHints.DiscardUnknown(m)
}

var xxx_messageInfo_GetHintsResponse_ResponseHints proto.InternalMessageInfo

func init() {
	proto.RegisterType((*ShardSpec)(nil), "consumer.ShardSpec")
	proto.RegisterType((*ShardSpec_Source)(nil), "consumer.ShardSpec.Source")
	proto.RegisterType((*ConsumerSpec)(nil), "consumer.ConsumerSpec")
	proto.RegisterType((*ReplicaStatus)(nil), "consumer.ReplicaStatus")
	proto.RegisterType((*ListRequest)(nil), "consumer.ListRequest")
	proto.RegisterType((*ListResponse)(nil), "consumer.ListResponse")
	proto.RegisterType((*ListResponse_Shard)(nil), "consumer.ListResponse.Shard")
	proto.RegisterType((*ApplyRequest)(nil), "consumer.ApplyRequest")
	proto.RegisterType((*ApplyRequest_Change)(nil), "consumer.ApplyRequest.Change")
	proto.RegisterType((*ApplyResponse)(nil), "consumer.ApplyResponse")
	proto.RegisterType((*StatRequest)(nil), "consumer.StatRequest")
	proto.RegisterType((*StatResponse)(nil), "consumer.StatResponse")
	proto.RegisterMapType((map[github_com_LiveRamp_gazette_v2_pkg_protocol.Journal]int64)(nil), "consumer.StatResponse.OffsetsEntry")
	proto.RegisterType((*GetHintsRequest)(nil), "consumer.GetHintsRequest")
	proto.RegisterType((*GetHintsResponse)(nil), "consumer.GetHintsResponse")
	proto.RegisterType((*GetHintsResponse_ResponseHints)(nil), "consumer.GetHintsResponse.ResponseHints")
	proto.RegisterEnum("consumer.Status", Status_name, Status_value)
	proto.RegisterEnum("consumer.ReplicaStatus_Code", ReplicaStatus_Code_name, ReplicaStatus_Code_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ShardClient is the client API for Shard service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ShardClient interface {
	// Stat returns detailed status of a given Shard.
	Stat(ctx context.Context, in *StatRequest, opts ...grpc.CallOption) (*StatResponse, error)
	// List Shards, their ShardSpecs and their processing status.
	List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error)
	// Apply changes to the collection of Shards managed by the consumer.
	Apply(ctx context.Context, in *ApplyRequest, opts ...grpc.CallOption) (*ApplyResponse, error)
	// GetHints fetchs hints for a shard.
	GetHints(ctx context.Context, in *GetHintsRequest, opts ...grpc.CallOption) (*GetHintsResponse, error)
}

type shardClient struct {
	cc *grpc.ClientConn
}

func NewShardClient(cc *grpc.ClientConn) ShardClient {
	return &shardClient{cc}
}

func (c *shardClient) Stat(ctx context.Context, in *StatRequest, opts ...grpc.CallOption) (*StatResponse, error) {
	out := new(StatResponse)
	err := c.cc.Invoke(ctx, "/consumer.Shard/Stat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shardClient) List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error) {
	out := new(ListResponse)
	err := c.cc.Invoke(ctx, "/consumer.Shard/List", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shardClient) Apply(ctx context.Context, in *ApplyRequest, opts ...grpc.CallOption) (*ApplyResponse, error) {
	out := new(ApplyResponse)
	err := c.cc.Invoke(ctx, "/consumer.Shard/Apply", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shardClient) GetHints(ctx context.Context, in *GetHintsRequest, opts ...grpc.CallOption) (*GetHintsResponse, error) {
	out := new(GetHintsResponse)
	err := c.cc.Invoke(ctx, "/consumer.Shard/GetHints", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ShardServer is the server API for Shard service.
type ShardServer interface {
	// Stat returns detailed status of a given Shard.
	Stat(context.Context, *StatRequest) (*StatResponse, error)
	// List Shards, their ShardSpecs and their processing status.
	List(context.Context, *ListRequest) (*ListResponse, error)
	// Apply changes to the collection of Shards managed by the consumer.
	Apply(context.Context, *ApplyRequest) (*ApplyResponse, error)
	// GetHints fetchs hints for a shard.
	GetHints(context.Context, *GetHintsRequest) (*GetHintsResponse, error)
}

func RegisterShardServer(s *grpc.Server, srv ShardServer) {
	s.RegisterService(&_Shard_serviceDesc, srv)
}

func _Shard_Stat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardServer).Stat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/consumer.Shard/Stat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardServer).Stat(ctx, req.(*StatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Shard_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/consumer.Shard/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardServer).List(ctx, req.(*ListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Shard_Apply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardServer).Apply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/consumer.Shard/Apply",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardServer).Apply(ctx, req.(*ApplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Shard_GetHints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHintsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardServer).GetHints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/consumer.Shard/GetHints",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardServer).GetHints(ctx, req.(*GetHintsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Shard_serviceDesc = grpc.ServiceDesc{
	ServiceName: "consumer.Shard",
	HandlerType: (*ShardServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Stat",
			Handler:    _Shard_Stat_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Shard_List_Handler,
		},
		{
			MethodName: "Apply",
			Handler:    _Shard_Apply_Handler,
		},
		{
			MethodName: "GetHints",
			Handler:    _Shard_GetHints_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "consumer.proto",
}

func (m *ShardSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Sources) > 0 {
		for _, msg := range m.Sources {
			dAtA[i] = 0x12
			i++
			i = encodeVarintConsumer(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RecoveryLogPrefix) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(len(m.RecoveryLogPrefix)))
		i += copy(dAtA[i:], m.RecoveryLogPrefix)
	}
	if len(m.HintPrefix) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(len(m.HintPrefix)))
		i += copy(dAtA[i:], m.HintPrefix)
	}
	if m.HintBackups != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(m.HintBackups))
	}
	dAtA[i] = 0x32
	i++
	i = encodeVarintConsumer(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.MaxTxnDuration)))
	n1, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.MaxTxnDuration, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x3a
	i++
	i = encodeVarintConsumer(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.MinTxnDuration)))
	n2, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.MinTxnDuration, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if m.Disable {
		dAtA[i] = 0x40
		i++
		if m.Disable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HotStandbys != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(m.HotStandbys))
	}
	dAtA[i] = 0x52
	i++
	i = encodeVarintConsumer(dAtA, i, uint64(m.LabelSet.ProtoSize()))
	n3, err := m.LabelSet.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	return i, nil
}

func (m *ShardSpec_Source) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardSpec_Source) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Journal) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(len(m.Journal)))
		i += copy(dAtA[i:], m.Journal)
	}
	if m.MinOffset != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(m.MinOffset))
	}
	return i, nil
}

func (m *ConsumerSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsumerSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintConsumer(dAtA, i, uint64(m.ProcessSpec.ProtoSize()))
	n4, err := m.ProcessSpec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if m.ShardLimit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(m.ShardLimit))
	}
	return i, nil
}

func (m *ReplicaStatus) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicaStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(m.Code))
	}
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *ListRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintConsumer(dAtA, i, uint64(m.Selector.ProtoSize()))
	n5, err := m.Selector.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	return i, nil
}

func (m *ListResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(m.Status))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintConsumer(dAtA, i, uint64(m.Header.ProtoSize()))
	n6, err := m.Header.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	if len(m.Shards) > 0 {
		for _, msg := range m.Shards {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintConsumer(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ListResponse_Shard) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListResponse_Shard) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintConsumer(dAtA, i, uint64(m.Spec.ProtoSize()))
	n7, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	if m.ModRevision != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(m.ModRevision))
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintConsumer(dAtA, i, uint64(m.Route.ProtoSize()))
	n8, err := m.Route.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	if len(m.Status) > 0 {
		for _, msg := range m.Status {
			dAtA[i] = 0x22
			i++
			i = encodeVarintConsumer(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ApplyRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Changes) > 0 {
		for _, msg := range m.Changes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintConsumer(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ApplyRequest_Change) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyRequest_Change) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ExpectModRevision != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(m.ExpectModRevision))
	}
	if m.Upsert != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(m.Upsert.ProtoSize()))
		n9, err := m.Upsert.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.Delete) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(len(m.Delete)))
		i += copy(dAtA[i:], m.Delete)
	}
	return i, nil
}

func (m *ApplyResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(m.Status))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintConsumer(dAtA, i, uint64(m.Header.ProtoSize()))
	n10, err := m.Header.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	return i, nil
}

func (m *StatRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(m.Header.ProtoSize()))
		n11, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.Shard) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(len(m.Shard)))
		i += copy(dAtA[i:], m.Shard)
	}
	return i, nil
}

func (m *StatResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(m.Status))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintConsumer(dAtA, i, uint64(m.Header.ProtoSize()))
	n12, err := m.Header.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	if len(m.Offsets) > 0 {
		for k, _ := range m.Offsets {
			dAtA[i] = 0x1a
			i++
			v := m.Offsets[k]
			mapSize := 1 + len(k) + sovConsumer(uint64(len(k))) + 1 + sovConsumer(uint64(v))
			i = encodeVarintConsumer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintConsumer(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintConsumer(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *GetHintsRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetHintsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Shard) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(len(m.Shard)))
		i += copy(dAtA[i:], m.Shard)
	}
	return i, nil
}

func (m *GetHintsResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetHintsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(m.Status))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintConsumer(dAtA, i, uint64(m.Header.ProtoSize()))
	n13, err := m.Header.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	dAtA[i] = 0x1a
	i++
	i = encodeVarintConsumer(dAtA, i, uint64(m.PrimaryHints.ProtoSize()))
	n14, err := m.PrimaryHints.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	if len(m.BackupHints) > 0 {
		for _, msg := range m.BackupHints {
			dAtA[i] = 0x22
			i++
			i = encodeVarintConsumer(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetHintsResponse_ResponseHints) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetHintsResponse_ResponseHints) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Hints != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConsumer(dAtA, i, uint64(m.Hints.ProtoSize()))
		n15, err := m.Hints.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func encodeVarintConsumer(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ShardSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovConsumer(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, e := range m.Sources {
			l = e.ProtoSize()
			n += 1 + l + sovConsumer(uint64(l))
		}
	}
	l = len(m.RecoveryLogPrefix)
	if l > 0 {
		n += 1 + l + sovConsumer(uint64(l))
	}
	l = len(m.HintPrefix)
	if l > 0 {
		n += 1 + l + sovConsumer(uint64(l))
	}
	if m.HintBackups != 0 {
		n += 1 + sovConsumer(uint64(m.HintBackups))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.MaxTxnDuration)
	n += 1 + l + sovConsumer(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.MinTxnDuration)
	n += 1 + l + sovConsumer(uint64(l))
	if m.Disable {
		n += 2
	}
	if m.HotStandbys != 0 {
		n += 1 + sovConsumer(uint64(m.HotStandbys))
	}
	l = m.LabelSet.ProtoSize()
	n += 1 + l + sovConsumer(uint64(l))
	return n
}

func (m *ShardSpec_Source) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Journal)
	if l > 0 {
		n += 1 + l + sovConsumer(uint64(l))
	}
	if m.MinOffset != 0 {
		n += 1 + sovConsumer(uint64(m.MinOffset))
	}
	return n
}

func (m *ConsumerSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ProcessSpec.ProtoSize()
	n += 1 + l + sovConsumer(uint64(l))
	if m.ShardLimit != 0 {
		n += 1 + sovConsumer(uint64(m.ShardLimit))
	}
	return n
}

func (m *ReplicaStatus) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovConsumer(uint64(m.Code))
	}
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			l = len(s)
			n += 1 + l + sovConsumer(uint64(l))
		}
	}
	return n
}

func (m *ListRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Selector.ProtoSize()
	n += 1 + l + sovConsumer(uint64(l))
	return n
}

func (m *ListResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovConsumer(uint64(m.Status))
	}
	l = m.Header.ProtoSize()
	n += 1 + l + sovConsumer(uint64(l))
	if len(m.Shards) > 0 {
		for _, e := range m.Shards {
			l = e.ProtoSize()
			n += 1 + l + sovConsumer(uint64(l))
		}
	}
	return n
}

func (m *ListResponse_Shard) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Spec.ProtoSize()
	n += 1 + l + sovConsumer(uint64(l))
	if m.ModRevision != 0 {
		n += 1 + sovConsumer(uint64(m.ModRevision))
	}
	l = m.Route.ProtoSize()
	n += 1 + l + sovConsumer(uint64(l))
	if len(m.Status) > 0 {
		for _, e := range m.Status {
			l = e.ProtoSize()
			n += 1 + l + sovConsumer(uint64(l))
		}
	}
	return n
}

func (m *ApplyRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Changes) > 0 {
		for _, e := range m.Changes {
			l = e.ProtoSize()
			n += 1 + l + sovConsumer(uint64(l))
		}
	}
	return n
}

func (m *ApplyRequest_Change) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExpectModRevision != 0 {
		n += 1 + sovConsumer(uint64(m.ExpectModRevision))
	}
	if m.Upsert != nil {
		l = m.Upsert.ProtoSize()
		n += 1 + l + sovConsumer(uint64(l))
	}
	l = len(m.Delete)
	if l > 0 {
		n += 1 + l + sovConsumer(uint64(l))
	}
	return n
}

func (m *ApplyResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovConsumer(uint64(m.Status))
	}
	l = m.Header.ProtoSize()
	n += 1 + l + sovConsumer(uint64(l))
	return n
}

func (m *StatRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.ProtoSize()
		n += 1 + l + sovConsumer(uint64(l))
	}
	l = len(m.Shard)
	if l > 0 {
		n += 1 + l + sovConsumer(uint64(l))
	}
	return n
}

func (m *StatResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovConsumer(uint64(m.Status))
	}
	l = m.Header.ProtoSize()
	n += 1 + l + sovConsumer(uint64(l))
	if len(m.Offsets) > 0 {
		for k, v := range m.Offsets {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovConsumer(uint64(len(k))) + 1 + sovConsumer(uint64(v))
			n += mapEntrySize + 1 + sovConsumer(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *GetHintsRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Shard)
	if l > 0 {
		n += 1 + l + sovConsumer(uint64(l))
	}
	return n
}

func (m *GetHintsResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovConsumer(uint64(m.Status))
	}
	l = m.Header.ProtoSize()
	n += 1 + l + sovConsumer(uint64(l))
	l = m.PrimaryHints.ProtoSize()
	n += 1 + l + sovConsumer(uint64(l))
	if len(m.BackupHints) > 0 {
		for _, e := range m.BackupHints {
			l = e.ProtoSize()
			n += 1 + l + sovConsumer(uint64(l))
		}
	}
	return n
}

func (m *GetHintsResponse_ResponseHints) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Hints != nil {
		l = m.Hints.ProtoSize()
		n += 1 + l + sovConsumer(uint64(l))
	}
	return n
}

func sovConsumer(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozConsumer(x uint64) (n int) {
	return sovConsumer(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ShardSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsumer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = ShardID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, ShardSpec_Source{})
			if err := m.Sources[len(m.Sources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoveryLogPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecoveryLogPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HintPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HintPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HintBackups", wireType)
			}
			m.HintBackups = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HintBackups |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTxnDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.MaxTxnDuration, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinTxnDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.MinTxnDuration, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disable = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HotStandbys", wireType)
			}
			m.HotStandbys = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HotStandbys |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LabelSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsumer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsumer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardSpec_Source) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsumer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Source: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Source: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Journal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Journal = github_com_LiveRamp_gazette_v2_pkg_protocol.Journal(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinOffset", wireType)
			}
			m.MinOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinOffset |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConsumer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsumer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsumerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsumer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsumerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsumerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProcessSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardLimit", wireType)
			}
			m.ShardLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardLimit |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConsumer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsumer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicaStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsumer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicaStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicaStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (ReplicaStatus_Code(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsumer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsumer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsumer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Selector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsumer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsumer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsumer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shards = append(m.Shards, ListResponse_Shard{})
			if err := m.Shards[len(m.Shards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsumer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsumer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListResponse_Shard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsumer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Shard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Shard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModRevision", wireType)
			}
			m.ModRevision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModRevision |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Route.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = append(m.Status, ReplicaStatus{})
			if err := m.Status[len(m.Status)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsumer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsumer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsumer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Changes = append(m.Changes, ApplyRequest_Change{})
			if err := m.Changes[len(m.Changes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsumer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsumer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyRequest_Change) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsumer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Change: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Change: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectModRevision", wireType)
			}
			m.ExpectModRevision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpectModRevision |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upsert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Upsert == nil {
				m.Upsert = &ShardSpec{}
			}
			if err := m.Upsert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delete = ShardID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsumer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsumer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsumer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsumer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsumer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsumer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &protocol.Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shard = ShardID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsumer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsumer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsumer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offsets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Offsets == nil {
				m.Offsets = make(map[github_com_LiveRamp_gazette_v2_pkg_protocol.Journal]int64)
			}
			var mapkey github_com_LiveRamp_gazette_v2_pkg_protocol.Journal
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConsumer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConsumer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthConsumer
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = github_com_LiveRamp_gazette_v2_pkg_protocol.Journal(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConsumer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipConsumer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthConsumer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Offsets[github_com_LiveRamp_gazette_v2_pkg_protocol.Journal(mapkey)] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsumer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsumer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetHintsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsumer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetHintsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetHintsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shard = ShardID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsumer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsumer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetHintsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsumer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetHintsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetHintsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryHints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrimaryHints.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupHints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackupHints = append(m.BackupHints, GetHintsResponse_ResponseHints{})
			if err := m.BackupHints[len(m.BackupHints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsumer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsumer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetHintsResponse_ResponseHints) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsumer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseHints: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseHints: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsumer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hints == nil {
				m.Hints = &recoverylog.FSMHints{}
			}
			if err := m.Hints.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsumer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsumer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipConsumer(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowConsumer
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConsumer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthConsumer
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowConsumer
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipConsumer(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthConsumer = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowConsumer   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("consumer.proto", fileDescriptor_consumer_9e9608ed376e3e47) }

var fileDescriptor_consumer_9e9608ed376e3e47 = []byte{
	// 1403 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xb1, 0x6f, 0xdb, 0xc6,
	0x17, 0x36, 0x25, 0x99, 0xb2, 0x1f, 0x65, 0x47, 0x3e, 0xc7, 0xb1, 0xa2, 0x24, 0x92, 0xcd, 0x64,
	0x10, 0x7e, 0xbf, 0x84, 0x0e, 0x94, 0x06, 0x49, 0x8d, 0xb6, 0xa8, 0x68, 0xd9, 0xb1, 0x1a, 0xc5,
	0x76, 0x28, 0x17, 0x68, 0xbb, 0x10, 0x14, 0x79, 0x96, 0xd9, 0x50, 0x3c, 0x96, 0xa4, 0x0c, 0xab,
	0x63, 0x81, 0x2e, 0x9d, 0x32, 0x16, 0x68, 0x87, 0xa2, 0x73, 0xff, 0x85, 0x02, 0x1d, 0x3d, 0x06,
	0x9d, 0x8a, 0x0e, 0x0a, 0x1a, 0xf7, 0x2f, 0xf0, 0x98, 0xa9, 0xe0, 0xdd, 0x51, 0xa2, 0x1c, 0x19,
	0x68, 0x0a, 0x64, 0xe3, 0xbd, 0xf7, 0xbd, 0xef, 0xdd, 0xfb, 0xee, 0xdd, 0x3b, 0xc2, 0xbc, 0x49,
	0xdc, 0xa0, 0xd7, 0xc5, 0xbe, 0xe2, 0xf9, 0x24, 0x24, 0x68, 0x26, 0x5e, 0x17, 0xd7, 0x3b, 0x76,
	0x78, 0xd8, 0x6b, 0x2b, 0x26, 0xe9, 0xae, 0x35, 0xed, 0x23, 0xac, 0x19, 0x5d, 0x6f, 0xad, 0x63,
	0x7c, 0x8d, 0xc3, 0x10, 0xaf, 0x1d, 0x55, 0xd7, 0xbc, 0x67, 0x9d, 0x35, 0x1a, 0x63, 0x12, 0x67,
	0xf8, 0xc1, 0x58, 0x8a, 0x1f, 0xff, 0x8b, 0x58, 0x1f, 0x9b, 0xe4, 0x08, 0xfb, 0x7d, 0x87, 0xb0,
	0x6f, 0xdf, 0xc2, 0x96, 0x4e, 0x3c, 0xce, 0x70, 0x27, 0xc1, 0xd0, 0x21, 0x1d, 0xc2, 0x32, 0xb4,
	0x7b, 0x07, 0x74, 0x45, 0x17, 0xf4, 0x8b, 0xc3, 0x4b, 0x1d, 0x42, 0x3a, 0x0e, 0x1e, 0xa1, 0xac,
	0x9e, 0x6f, 0x84, 0x36, 0x71, 0x99, 0x5f, 0xfe, 0x2d, 0x0b, 0xb3, 0xad, 0x43, 0xc3, 0xb7, 0x5a,
	0x1e, 0x36, 0xd1, 0x5d, 0x48, 0xd9, 0x56, 0x41, 0x58, 0x11, 0x2a, 0xb3, 0xea, 0xca, 0xd9, 0xa0,
	0xbc, 0xd0, 0x37, 0xba, 0xce, 0xba, 0x7c, 0x9b, 0x74, 0xed, 0x10, 0x77, 0xbd, 0xb0, 0x2f, 0xbf,
	0x1e, 0x94, 0xb3, 0x14, 0xdf, 0xa8, 0x6b, 0x29, 0xdb, 0x42, 0xbb, 0x90, 0x0d, 0x48, 0xcf, 0x37,
	0x71, 0x50, 0x48, 0xad, 0xa4, 0x2b, 0x52, 0xb5, 0xa8, 0x0c, 0x85, 0x1b, 0xf2, 0x2a, 0x2d, 0x0a,
	0x51, 0xaf, 0x9e, 0x0c, 0xca, 0x53, 0x13, 0x69, 0xb5, 0x98, 0x05, 0x7d, 0x06, 0x8b, 0xb1, 0x00,
	0xba, 0x43, 0x3a, 0xba, 0xe7, 0xe3, 0x03, 0xfb, 0xb8, 0x90, 0xa6, 0x7b, 0xaa, 0x9c, 0x0d, 0xca,
	0xb7, 0x58, 0xf0, 0x04, 0x50, 0x92, 0x6f, 0x21, 0xf6, 0x37, 0x49, 0x67, 0x8f, 0x7a, 0x51, 0x0d,
	0xa4, 0x43, 0xdb, 0x0d, 0x63, 0xc6, 0xcc, 0xb0, 0xca, 0xeb, 0x8c, 0x31, 0xe1, 0x4c, 0x32, 0x41,
	0x64, 0xe7, 0x14, 0x75, 0xc8, 0x51, 0x54, 0xdb, 0x30, 0x9f, 0xf5, 0xbc, 0xa0, 0x30, 0xbd, 0x22,
	0x54, 0xa6, 0xd5, 0xd5, 0xb3, 0x41, 0xf9, 0x46, 0x82, 0x83, 0x7b, 0x93, 0x24, 0x34, 0xb3, 0xca,
	0xec, 0xc8, 0x87, 0x7c, 0xd7, 0x38, 0xd6, 0xc3, 0x63, 0x57, 0x8f, 0x4f, 0xa3, 0x20, 0xae, 0x08,
	0x15, 0xa9, 0x7a, 0x55, 0x61, 0xc7, 0xa5, 0xc4, 0xc7, 0xa5, 0xd4, 0x39, 0x40, 0xbd, 0xc3, 0xb5,
	0x5b, 0x65, 0x89, 0xce, 0x13, 0x24, 0x92, 0x7d, 0xff, 0xb2, 0x2c, 0x68, 0xf3, 0x5d, 0xe3, 0x78,
	0xff, 0xd8, 0x8d, 0xc3, 0x69, 0x4e, 0xdb, 0x1d, 0xcf, 0x99, 0x7d, 0xdb, 0x9c, 0xe7, 0x08, 0xde,
	0xcc, 0x69, 0xbb, 0xc9, 0x9c, 0x6b, 0x90, 0xb5, 0xec, 0xc0, 0x68, 0x3b, 0xb8, 0x30, 0xb3, 0x22,
	0x54, 0x66, 0xd4, 0xa5, 0x0b, 0xce, 0x9e, 0xa3, 0xa8, 0xbc, 0x24, 0xd4, 0x83, 0xd0, 0x70, 0xad,
	0x76, 0x3f, 0x28, 0xcc, 0xae, 0x08, 0x95, 0xb9, 0x31, 0x79, 0x13, 0xde, 0x71, 0x79, 0x49, 0xd8,
	0xe2, 0x76, 0xb4, 0x07, 0xa2, 0x63, 0xb4, 0xb1, 0x13, 0x14, 0x80, 0x16, 0x88, 0x94, 0xe1, 0x25,
	0x6c, 0x46, 0xf6, 0x16, 0x0e, 0xd5, 0x5b, 0x51, 0x65, 0x2f, 0x06, 0x65, 0xe1, 0x6c, 0x50, 0x2e,
	0x9c, 0xdf, 0xd1, 0x6d, 0xdb, 0x75, 0x6c, 0x17, 0xcb, 0x1a, 0xe7, 0x29, 0xfe, 0x20, 0x80, 0xc8,
	0x5a, 0x18, 0x3d, 0x85, 0xec, 0x97, 0xa4, 0xe7, 0xbb, 0x86, 0xc3, 0xaf, 0xc9, 0x83, 0xd7, 0x83,
	0xf2, 0xbd, 0xb7, 0x98, 0x08, 0xca, 0x27, 0x2c, 0x5c, 0x8b, 0x79, 0xd0, 0x47, 0x00, 0x91, 0xb2,
	0xe4, 0xe0, 0x20, 0xc0, 0x21, 0x6d, 0xf4, 0xb4, 0x5a, 0x3e, 0x1b, 0x94, 0xaf, 0x8d, 0x54, 0x67,
	0xbe, 0x64, 0xc5, 0xb3, 0x5d, 0xdb, 0xdd, 0xa5, 0x56, 0xf9, 0x5b, 0x01, 0x72, 0x1b, 0xfc, 0xce,
	0xd1, 0x5b, 0xbc, 0x0f, 0x39, 0xcf, 0x27, 0x26, 0x0e, 0x02, 0x3d, 0xf0, 0xb0, 0x49, 0x37, 0x2a,
	0x55, 0x97, 0x46, 0x32, 0xec, 0x31, 0x6f, 0x04, 0x56, 0x8b, 0x09, 0x25, 0xe6, 0xb9, 0x12, 0x71,
	0xfd, 0x92, 0x37, 0x02, 0xa2, 0x32, 0x48, 0x41, 0x74, 0xa1, 0x75, 0xc7, 0xee, 0xda, 0x61, 0x21,
	0x15, 0x9d, 0x8d, 0x06, 0xd4, 0xd4, 0x8c, 0x2c, 0xf2, 0xcf, 0x02, 0xcc, 0x69, 0xd8, 0x73, 0x6c,
	0xd3, 0x68, 0x85, 0x46, 0xd8, 0x0b, 0xd0, 0x5d, 0xc8, 0x98, 0xc4, 0xc2, 0x74, 0x03, 0xf3, 0xd5,
	0xeb, 0xa3, 0xc9, 0x30, 0x06, 0x53, 0x36, 0x88, 0x85, 0x35, 0x8a, 0x44, 0x57, 0x40, 0xc4, 0xbe,
	0x4f, 0x7c, 0x36, 0x4d, 0x66, 0x35, 0xbe, 0x92, 0x1f, 0x41, 0x26, 0x42, 0xa1, 0x19, 0xc8, 0x34,
	0xea, 0xcd, 0xcd, 0xfc, 0x14, 0xca, 0xc1, 0x8c, 0x5a, 0xdb, 0x78, 0xbc, 0xd5, 0x68, 0x36, 0xf3,
	0x16, 0xca, 0x41, 0x76, 0xbf, 0xd6, 0x68, 0x36, 0x76, 0x1e, 0xe5, 0x4f, 0x84, 0x68, 0xb5, 0xa7,
	0x35, 0x9e, 0xd4, 0xb4, 0xcf, 0xf3, 0xbf, 0xa4, 0x90, 0x04, 0xe2, 0x56, 0xad, 0xd1, 0xdc, 0xac,
	0xe7, 0x9f, 0xa7, 0xe5, 0x6d, 0x90, 0x9a, 0x76, 0x10, 0x6a, 0xf8, 0xab, 0x1e, 0x0e, 0x42, 0xf4,
	0x3e, 0xcc, 0x04, 0xd8, 0xc1, 0x66, 0x48, 0x7c, 0x2e, 0xd3, 0xf2, 0x1b, 0xdd, 0xc2, 0xdc, 0x6a,
	0x26, 0x12, 0x4a, 0x1b, 0xc2, 0xe5, 0xbf, 0x53, 0x90, 0x63, 0x54, 0x81, 0x47, 0xdc, 0x00, 0xa3,
	0x0a, 0x88, 0x01, 0x2d, 0x88, 0xd7, 0x9b, 0x4f, 0x4c, 0x42, 0x6a, 0xd7, 0xb8, 0x1f, 0x29, 0x20,
	0x1e, 0x62, 0xc3, 0xc2, 0x3e, 0x55, 0x51, 0xaa, 0xe6, 0x47, 0x39, 0xb7, 0xa9, 0x9d, 0x27, 0xe3,
	0x28, 0xb4, 0x0e, 0x22, 0xd5, 0x39, 0x28, 0xa4, 0xe9, 0x8c, 0x4d, 0x28, 0x99, 0xdc, 0x01, 0x1b,
	0xb8, 0x71, 0x2c, 0x8b, 0x28, 0xfe, 0x2a, 0xc0, 0x34, 0xb5, 0xa3, 0x3b, 0x90, 0x49, 0xb4, 0xc3,
	0xe2, 0x84, 0x39, 0xcd, 0x43, 0x29, 0x0c, 0xad, 0x42, 0xae, 0x4b, 0x2c, 0xdd, 0xc7, 0x47, 0x76,
	0x10, 0x4d, 0x8b, 0x68, 0xab, 0x69, 0x4d, 0xea, 0x12, 0x4b, 0xe3, 0x26, 0xf4, 0x7f, 0x98, 0xf6,
	0x49, 0x2f, 0xc4, 0xb4, 0x69, 0xa5, 0xea, 0xa5, 0x51, 0x19, 0x5a, 0x64, 0xe6, 0x74, 0x0c, 0x83,
	0xee, 0x0f, 0xe5, 0xc9, 0xd0, 0x22, 0x96, 0x2f, 0x68, 0x87, 0xe1, 0xfe, 0xe9, 0x4a, 0xfe, 0x53,
	0x80, 0x5c, 0xcd, 0xf3, 0x9c, 0x7e, 0x7c, 0x64, 0x1f, 0x42, 0xd6, 0x3c, 0x34, 0xdc, 0x0e, 0x8e,
	0x74, 0x8e, 0x88, 0x6e, 0x8c, 0x88, 0x92, 0x40, 0x65, 0x83, 0xa2, 0x38, 0x5d, 0x1c, 0x53, 0xfc,
	0x4e, 0x00, 0x91, 0x79, 0x90, 0x02, 0x8b, 0xf8, 0xd8, 0xc3, 0x66, 0xa8, 0x8f, 0x15, 0x2a, 0xd0,
	0x42, 0x17, 0x98, 0xeb, 0xc9, 0x58, 0xb9, 0x62, 0xcf, 0x0b, 0xb0, 0x1f, 0xf2, 0x63, 0x9b, 0x24,
	0xa1, 0xc6, 0x21, 0xe8, 0x26, 0x88, 0x16, 0x76, 0x30, 0x17, 0x67, 0x56, 0x95, 0x92, 0x2f, 0x27,
	0x77, 0xc9, 0x36, 0xcc, 0xf1, 0x2d, 0xbf, 0xeb, 0x1e, 0x92, 0xbf, 0x00, 0x29, 0x62, 0x88, 0x55,
	0xac, 0x0c, 0xc3, 0x85, 0xc9, 0xe1, 0xc3, 0xe6, 0x5b, 0x85, 0x69, 0xda, 0x4a, 0x34, 0xcf, 0xb9,
	0x3a, 0x98, 0x47, 0xfe, 0x31, 0x05, 0x39, 0x46, 0xfe, 0xce, 0xaf, 0xc2, 0x11, 0x64, 0xd9, 0x30,
	0x8c, 0xef, 0xc2, 0xcd, 0x71, 0xea, 0xe1, 0x5d, 0x60, 0xc3, 0x31, 0xd8, 0x74, 0x43, 0xbf, 0xaf,
	0x3e, 0xf8, 0xe6, 0xe5, 0x7f, 0x1c, 0xd2, 0x3c, 0x59, 0x71, 0x1d, 0x72, 0x49, 0x46, 0x94, 0x87,
	0xf4, 0x33, 0xdc, 0x67, 0x6f, 0x80, 0x16, 0x7d, 0xa2, 0xcb, 0x30, 0x7d, 0x64, 0x38, 0x3d, 0xcc,
	0x2f, 0x0a, 0x5b, 0xac, 0xa7, 0x1e, 0x0a, 0xf2, 0x7b, 0x70, 0xe9, 0x11, 0x0e, 0xb7, 0x6d, 0x37,
	0x0c, 0x62, 0xf9, 0x87, 0xa2, 0x0a, 0x17, 0x8a, 0xfa, 0x7b, 0x0a, 0xf2, 0xa3, 0xb0, 0x77, 0x2e,
	0x6c, 0x0b, 0xe6, 0x3c, 0xdf, 0xee, 0x1a, 0x7e, 0x5f, 0x8f, 0xfe, 0x55, 0x02, 0x7e, 0xa7, 0x2b,
	0xa3, 0x04, 0xe7, 0x37, 0xa3, 0xc4, 0x1f, 0xd4, 0xca, 0xe9, 0x72, 0x9c, 0x84, 0xda, 0xd0, 0x53,
	0xc8, 0xb1, 0x9f, 0x21, 0xce, 0xc9, 0x6e, 0xfe, 0xdb, 0x72, 0x4a, 0x8c, 0x83, 0x9a, 0x8a, 0x1f,
	0x44, 0x8f, 0x4c, 0x02, 0x13, 0x0d, 0x21, 0x46, 0x1e, 0x3f, 0x73, 0x89, 0xff, 0x67, 0x65, 0xab,
	0xf5, 0x84, 0xf1, 0x33, 0xcc, 0xff, 0x08, 0x88, 0xfc, 0x6d, 0x12, 0x21, 0xb5, 0xfb, 0x38, 0x3f,
	0x85, 0x16, 0xe1, 0x52, 0x6b, 0xbb, 0xa6, 0xd5, 0xf5, 0x9d, 0xdd, 0x7d, 0x7d, 0x6b, 0xf7, 0xd3,
	0x9d, 0x7a, 0x5e, 0x40, 0x97, 0x21, 0xbf, 0xb3, 0xab, 0x33, 0x7b, 0xfc, 0x92, 0xa4, 0xd0, 0x12,
	0x2c, 0x44, 0xa0, 0x71, 0x73, 0x1a, 0x5d, 0x83, 0xe5, 0xcd, 0xfd, 0x8d, 0xba, 0xbe, 0xaf, 0xd5,
	0x76, 0x5a, 0xb5, 0x8d, 0xfd, 0xc6, 0xee, 0x8e, 0xce, 0x1f, 0x9c, 0x4c, 0xf5, 0x6c, 0x38, 0x7e,
	0xef, 0x43, 0x26, 0x4a, 0x8d, 0x96, 0xce, 0x37, 0x2c, 0xed, 0x88, 0xe2, 0x95, 0xc9, 0x7d, 0x1c,
	0x85, 0x45, 0x33, 0x3e, 0x19, 0x96, 0x78, 0xc0, 0x92, 0x61, 0x63, 0x8f, 0xd1, 0x43, 0x98, 0xa6,
	0x93, 0x05, 0x5d, 0x99, 0x3c, 0x1d, 0x8b, 0xcb, 0x6f, 0xd8, 0x79, 0x64, 0x0d, 0x66, 0xe2, 0x53,
	0x41, 0x57, 0x27, 0x9d, 0x14, 0x8b, 0x2f, 0x5e, 0x7c, 0x88, 0xea, 0xf5, 0x93, 0xbf, 0x4a, 0x53,
	0x27, 0xaf, 0x4a, 0xc2, 0x8b, 0x57, 0x25, 0xe1, 0xf9, 0x69, 0x69, 0xea, 0xa7, 0xd3, 0x92, 0xf0,
	0xe2, 0xb4, 0x34, 0xf5, 0xc7, 0x69, 0x69, 0xaa, 0x2d, 0xd2, 0x46, 0xbc, 0xf7, 0x4f, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x54, 0x4a, 0x1a, 0x5c, 0x62, 0x0d, 0x00, 0x00,
}
