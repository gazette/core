// Package editor provides utilities for editing and re-editing text files in
// an editor until the changes are accepted or the user aborts the attempt.
package editor

import (
	"bufio"
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"

	log "github.com/sirupsen/logrus"
)

var whitespace = regexp.MustCompile(`^\s*$`)

// RetryLoopArgs is arguments of EditRetryLoop.
type RetryLoopArgs struct {
	// FilePrefix
	FilePrefix string
	// SelectFn returns content to be displayed within the editor.
	// It is invoked on each retry of the editing loop.
	SelectFn func() io.Reader
	// ApplyFn attempts to apply the edited contents. If it returns
	// an error, the editor will be re-opened with the error message.
	ApplyFn func(b []byte) error
	// AbortIfUnchanged indicates the editing loop should abort if the
	// editor exits without making any file changes. In this case,
	// ApplyFn is not called with edited content.
	AbortIfUnchanged bool
}

// EditRetryLoop seeds a temp file, prefixed with FilePrefix, with content from
// SelectFn and passes it to ApplyFn. If ApplyFn errors, the editor will be
// re-opened with recent error message included in the header comments. The
// current implementation prefixes comment lines with "#".
func EditRetryLoop(args RetryLoopArgs) error {
	var (
		isRetry  bool
		retryMsg string

		// userEdits contains the last version of the edits made by the user.
		// Any comments generated by the edit-retry loop are not included.
		userEdits []byte

		// preservedEdits contains the name of the last temp file used by the
		// editor. This file is preserved when the user cancels an edit attempt
		// that has failed validation at least once. If a user cancels without
		// attempting any changes, it is considered a no-op and nothing is
		// preserved.
		preservedEdits *string
	)

	// Notify users of preserved edits if they exist.
	defer func() {
		if preservedEdits == nil {
			return
		}
		if _, err := os.Stat(*preservedEdits); err == nil {
			_, _ = fmt.Fprintf(os.Stderr, "Last edits saved to %s.\n", *preservedEdits)
		}
	}()

	for {
		var buf = &bytes.Buffer{}
		var preEdit []byte
		var headerLines = 0

		headerLines += writeHeader(buf)

		if isRetry {
			if retryMsg != "" {
				headerLines += writeRetryMessage(buf, retryMsg)
			}
			writePostHeader(buf, headerLines)
			buf.Write(userEdits)
			preEdit = userEdits
		} else {
			writePostHeader(buf, headerLines)
			if _, err := io.Copy(buf, args.SelectFn()); err != nil {
				return err
			}
			preEdit = pruneHeader(buf.Bytes())
		}

		var edited, currPath, err = editToTempFile(args.FilePrefix, buf)
		if err != nil {
			return err
		}

		// Now that a newer temp file is written to disk, it is safe to remove
		// the previous one.
		if preservedEdits != nil {
			log.WithField("file", *preservedEdits).Debug("remove temp file")
			_ = os.Remove(*preservedEdits)
		}
		preservedEdits = &currPath

		userEdits = pruneHeader(edited)
		if isEmptyEdit(userEdits) {
			log.WithField("file", currPath).Debug("remove temp file")
			_ = os.Remove(currPath)
			_, _ = fmt.Fprintln(os.Stderr, "Cancelled; empty file.")
			return nil
		}

		// When a user does not make any edit, it is interpreted as a
		// cancellation of the edit attempt.
		if args.AbortIfUnchanged && bytes.Equal(preEdit, userEdits) {
			if isRetry {
				// When at least one edit attempt was made before cancelling,
				// do not remove the temp file as it contains changes.
				_, _ = fmt.Fprintln(os.Stderr, "Cancelled; no changes to invalid file.")
			} else {
				// When no edit attempt is made before cancelling, it is
				// redundant to keep the temp file because the contents can be
				// fully regenerated.
				log.WithField("file", currPath).Debug("remove temp file")
				_ = os.Remove(currPath)
				_, _ = fmt.Fprintln(os.Stderr, "Cancelled; nothing to do.")
			}
			return nil
		}

		// Attempt to apply edits.
		if err = args.ApplyFn(userEdits); err != nil {
			isRetry = true
			retryMsg = err.Error()
			continue
		}

		_ = os.Remove(currPath)
		return nil
	}
}

// editToTempFile presents the contents of r to the user for editing and saves
// the result in a temp file with the given prefix.
func editToTempFile(prefix string, r io.Reader) ([]byte, string, error) {
	var tmpFile, errTemp = ioutil.TempFile("", prefix)
	if errTemp != nil {
		return nil, "", errTemp
	}
	var path = tmpFile.Name()
	defer func() {
		_ = tmpFile.Close()
	}()

	if _, err := io.Copy(tmpFile, r); err != nil {
		_ = os.Remove(path)
		return nil, "", err
	}
	log.WithField("file", path).Debug("write temp file")

	// Must close the file before the editor can open it.
	_ = tmpFile.Close()
	if err := editWithEditor(path); err != nil {
		return nil, path, err
	}

	var b, errRead = ioutil.ReadFile(path)
	return b, path, errRead
}

// editWithEditor opens the file at the given path in an editor.
func editWithEditor(path string) error {
	var absPath, err = filepath.Abs(path)
	if err != nil {
		return err
	}

	cmd := exec.Command("/bin/sh", "-c", editor()+" "+absPath)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.Stdin = os.Stdin
	return cmd.Run()
}

func editor() string {
	var vs = []string{"GAZ_EDITOR", "EDITOR"}
	for _, v := range vs {
		if e := os.Getenv(v); e != "" {
			return e
		}
	}

	return "vi"
}

// isEmptyEdit returns true iff b contains only whitespace.
func isEmptyEdit(b []byte) bool {
	return whitespace.Match(b)
}

func writeHeader(w io.Writer) int {
	_, _ = fmt.Fprint(w, `#⚙ Edit the spec below. Lines beginning with a '#⚙' or '#⚠' are generated by
#⚙ this tool and will be ignored as input. An empty file will abort the edit.
#⚙ If there is an error validating and applying this file, it will be reopened.
#⚙
`)
	return 4
}

func writeRetryMessage(w io.Writer, msg string) int {
	// Highlight error message with U+26A0 aka ⚠ aka "warning sign".
	_, _ = fmt.Fprintln(w, "#\u26a0 There were errors validating or applying the spec. No changes were applied.\n#\u26a0")
	var lines = bytes.Split([]byte(msg), []byte("\n"))
	for _, line := range lines {
		_, _ = fmt.Fprintf(w, "#\u26a0 %s\n", line)
	}
	_, _ = fmt.Fprintln(w, "#\u26a0")
	return len(lines) + 3
}

func writePostHeader(w io.Writer, n int) {
	_, _ = fmt.Fprintf(w, "#⚙ Note: Any line numbers above do not include this header (%d lines).\n#⚙\n", n+2)
}

func pruneHeader(b []byte) []byte {
	var pruned []byte
	var s = bufio.NewScanner(bytes.NewReader(b))

	for s.Scan() {
		var line = s.Bytes()
		if bytes.HasPrefix(line, []byte("#⚙")) || bytes.HasPrefix(line, []byte("#\u26a0")) {
			continue
		}
		pruned = append(pruned, line...)
		pruned = append(pruned, '\n')
	}

	if err := s.Err(); err != nil {
		log.WithField("err", err).Panic("unable to prune header comments")
	}

	return pruned
}
